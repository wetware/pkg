package socket_test

import (
	"testing"

	"github.com/libp2p/go-libp2p"
	"github.com/libp2p/go-libp2p/core/peer"
	"github.com/libp2p/go-libp2p/core/record"
	inproc "github.com/lthibault/go-libp2p-inproc-transport"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
	"github.com/wetware/pkg/api/boot"
	"github.com/wetware/pkg/boot/socket"
)

func TestNewCache(t *testing.T) {
	t.Parallel()

	/*
	 * To simplify cache creation, we enforce some invariants on the size of the
	 * cache, and default to a reasonable value (size=8) if users try to create
	 * a cache that is too small (< 2).  Here, we just verify that invalid cache
	 * sizes fall back on the default value rather than triggering a panic.
	 */

	for i := -1; i < 10; i++ {
		assert.NotPanics(t, func() {
			socket.NewCache(i)
		}, "should not panic with size %d", i)
	}
}

func TestCache(t *testing.T) {
	t.Parallel()
	t.Helper()

	/*
	 * The purpose of this test is to enforce high-level invariants of the RecordCache.
	 * In particular, it checks (1) that LoadRequest, LoadResponse & LoadSurveyRequest
	 * each return a different envelope payload, and (2) that the payloads returned by
	 * a given method are consistent across calls.
	 *
	 * In short:  this test is intended to be coarse-grained.  Resist the urge to test
	 * for more subtle behaviors in TestCache, and instead write new test functions.
	 */

	h, err := libp2p.New(
		libp2p.NoTransports,
		libp2p.NoListenAddrs,
		libp2p.Transport(inproc.New()),
		libp2p.ListenAddrStrings("/inproc/~"))
	require.NoError(t, err, "must create test host")

	seal := func(r record.Record) (*record.Envelope, error) {
		return record.Seal(r, h.Peerstore().PrivKey(h.ID()))
	}

	var (
		cache          = socket.NewCache(8)
		req, res, surv *record.Envelope
	)

	// Test LoadRequest by calling it twice.  The first call should generate a new record
	// and the second call should return the cached record.  We do a quick-and-dirty test
	// that asserts these two records are equal.
	t.Run("LoadRequest", func(t *testing.T) {
		// First call to LoadRequest will generate record
		req, err = cache.LoadRequest(seal, h.ID(), "test")
		require.NoError(t, err, "must generate cache entry")

		// Second call to LoadRequest will load record from cache
		req2, err := cache.LoadRequest(seal, h.ID(), "test")
		require.NoError(t, err, "must generate cache entry for request payload")

		require.True(t, req2.Equal(req), "e2 should be equal to e")
	})

	// Now we call LoadResponse and check that the result is different from e and e2.
	// This is a regression test against a bug where all records were stored under
	// the same key.
	t.Run("LoadResponse", func(t *testing.T) {
		res, err = cache.LoadResponse(seal, h, "test")
		require.NoError(t, err, "must generate cache entry for response payload")
		require.False(t, res.Equal(req), "res should contain a different payload than req")
	})

	// Lastly, check that LoadSurveyRequest returns a payload distinct from the first two.
	t.Run("LoadSurveyRequest", func(t *testing.T) {
		surv, err = cache.LoadSurveyRequest(seal, h.ID(), "test", 8)
		require.NoError(t, err, "must generate cache entry for response payload")
		require.False(t, surv.Equal(req), "surv should contain a different payload than req")
	})
}

func TestCachedRecord(t *testing.T) {
	t.Parallel()
	t.Helper()

	/*
	 *  The purpose of this test is to check for bugs in the fields of records
	 *  generated by the cache.  This is distinct from TestCache, which checks
	 *  that the various Load* methods return different values.
	 */

	h, err := libp2p.New(
		libp2p.NoTransports,
		libp2p.NoListenAddrs,
		libp2p.Transport(inproc.New()),
		libp2p.ListenAddrStrings("/inproc/~"))
	require.NoError(t, err, "must create test host")

	seal := func(r record.Record) (*record.Envelope, error) {
		return record.Seal(r, h.Peerstore().PrivKey(h.ID()))
	}

	cache := socket.NewCache(8)

	t.Run("LoadRequest", func(t *testing.T) {
		t.Parallel()

		e, err := cache.LoadRequest(seal, h.ID(), "test")
		require.NoError(t, err, "should generate request payload")
		require.NotNil(t, e, "should return envelope")

		r, err := e.Record()
		require.NoError(t, err, "should return record")
		require.IsType(t, new(socket.Record), r, "should be socket.Record")

		rec := r.(*socket.Record)
		require.Equal(t, socket.TypeRequest, rec.Type(), "should be of type 'request'")

		ns, err := rec.Namespace()
		require.NoError(t, err, "should contain valid namespace")
		assert.Equal(t, "test", ns, "namespace should match call to LoadRequest()")

		id, err := rec.Peer()
		require.NoError(t, err, "should contain valid peer.ID")
		assert.Equal(t, h.ID(), id, "peer ID should match host")
	})

	t.Run("LoadSurveyRequest", func(t *testing.T) {
		t.Parallel()

		e, err := cache.LoadSurveyRequest(seal, h.ID(), "test", 8)
		require.NoError(t, err, "should generate request payload")
		require.NotNil(t, e, "should return envelope")

		r, err := e.Record()
		require.NoError(t, err, "should return record")
		require.IsType(t, new(socket.Record), r, "should be socket.Record")

		rec := r.(*socket.Record)
		require.Equal(t, socket.TypeSurvey, rec.Type(), "should be of type 'request'")

		ns, err := rec.Namespace()
		require.NoError(t, err, "should contain valid namespace")
		assert.Equal(t, "test", ns, "namespace should match call to LoadSurveyRequest()")

		id, err := rec.Peer()
		require.NoError(t, err, "should contain valid peer.ID")
		assert.Equal(t, h.ID(), id, "peer ID should match host")

		assert.Equal(t, uint8(8), (*boot.Packet)(rec).Survey().Distance(),
			"distance should match LoadSurveyRequest()")
	})

	t.Run("LoadResponse", func(t *testing.T) {
		t.Parallel()

		e, err := cache.LoadResponse(seal, h, "test")
		require.NoError(t, err, "should generate request payload")
		require.NotNil(t, e, "should return envelope")

		r, err := e.Record()
		require.NoError(t, err, "should return record")
		require.IsType(t, new(socket.Record), r, "should be socket.Record")

		rec := r.(*socket.Record)
		require.Equal(t, socket.TypeResponse, rec.Type(), "should be of type 'request'")

		ns, err := rec.Namespace()
		require.NoError(t, err, "should contain valid namespace")
		assert.Equal(t, "test", ns, "namespace should match call to LoadResponse()")

		id, err := rec.Peer()
		require.NoError(t, err, "should contain valid peer.ID")
		assert.Equal(t, h.ID(), id, "peer ID should match host")

		var info peer.AddrInfo
		err = socket.Response{Record: *rec}.Bind(&info)
		require.NoError(t, err, "should bind to peer.AddrInfo")
		assert.Equal(t, h.ID(), info.ID, "id should match host")
		assert.Equal(t, h.Addrs(), info.Addrs, "addrs should match host")
	})
}
