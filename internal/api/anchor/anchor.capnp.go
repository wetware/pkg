// Code generated by capnpc-go. DO NOT EDIT.

package anchor

import (
	capnp "capnproto.org/go/capnp/v3"
	text "capnproto.org/go/capnp/v3/encoding/text"
	schemas "capnproto.org/go/capnp/v3/schemas"
	server "capnproto.org/go/capnp/v3/server"
	context "context"
)

type Anchor struct{ Client *capnp.Client }

// Anchor_TypeID is the unique identifier for the type Anchor.
const Anchor_TypeID = 0xaebf015e04f2d0ad

func (c Anchor) Ls(ctx context.Context, params func(Anchor_ls_Params) error) (Anchor_ls_Results_Future, capnp.ReleaseFunc) {
	s := capnp.Send{
		Method: capnp.Method{
			InterfaceID:   0xaebf015e04f2d0ad,
			MethodID:      0,
			InterfaceName: "anchor.capnp:Anchor",
			MethodName:    "ls",
		},
	}
	if params != nil {
		s.ArgsSize = capnp.ObjectSize{DataSize: 0, PointerCount: 1}
		s.PlaceArgs = func(s capnp.Struct) error { return params(Anchor_ls_Params{Struct: s}) }
	}
	ans, release := c.Client.SendCall(ctx, s)
	return Anchor_ls_Results_Future{Future: ans.Future()}, release
}
func (c Anchor) Walk(ctx context.Context, params func(Anchor_walk_Params) error) (Anchor_walk_Results_Future, capnp.ReleaseFunc) {
	s := capnp.Send{
		Method: capnp.Method{
			InterfaceID:   0xaebf015e04f2d0ad,
			MethodID:      1,
			InterfaceName: "anchor.capnp:Anchor",
			MethodName:    "walk",
		},
	}
	if params != nil {
		s.ArgsSize = capnp.ObjectSize{DataSize: 0, PointerCount: 1}
		s.PlaceArgs = func(s capnp.Struct) error { return params(Anchor_walk_Params{Struct: s}) }
	}
	ans, release := c.Client.SendCall(ctx, s)
	return Anchor_walk_Results_Future{Future: ans.Future()}, release
}

func (c Anchor) AddRef() Anchor {
	return Anchor{
		Client: c.Client.AddRef(),
	}
}

func (c Anchor) Release() {
	c.Client.Release()
}

// A Anchor_Server is a Anchor with a local implementation.
type Anchor_Server interface {
	Ls(context.Context, Anchor_ls) error

	Walk(context.Context, Anchor_walk) error
}

// Anchor_NewServer creates a new Server from an implementation of Anchor_Server.
func Anchor_NewServer(s Anchor_Server, policy *server.Policy) *server.Server {
	c, _ := s.(server.Shutdowner)
	return server.New(Anchor_Methods(nil, s), s, c, policy)
}

// Anchor_ServerToClient creates a new Client from an implementation of Anchor_Server.
// The caller is responsible for calling Release on the returned Client.
func Anchor_ServerToClient(s Anchor_Server, policy *server.Policy) Anchor {
	return Anchor{Client: capnp.NewClient(Anchor_NewServer(s, policy))}
}

// Anchor_Methods appends Methods to a slice that invoke the methods on s.
// This can be used to create a more complicated Server.
func Anchor_Methods(methods []server.Method, s Anchor_Server) []server.Method {
	if cap(methods) == 0 {
		methods = make([]server.Method, 0, 2)
	}

	methods = append(methods, server.Method{
		Method: capnp.Method{
			InterfaceID:   0xaebf015e04f2d0ad,
			MethodID:      0,
			InterfaceName: "anchor.capnp:Anchor",
			MethodName:    "ls",
		},
		Impl: func(ctx context.Context, call *server.Call) error {
			return s.Ls(ctx, Anchor_ls{call})
		},
	})

	methods = append(methods, server.Method{
		Method: capnp.Method{
			InterfaceID:   0xaebf015e04f2d0ad,
			MethodID:      1,
			InterfaceName: "anchor.capnp:Anchor",
			MethodName:    "walk",
		},
		Impl: func(ctx context.Context, call *server.Call) error {
			return s.Walk(ctx, Anchor_walk{call})
		},
	})

	return methods
}

// Anchor_ls holds the state for a server call to Anchor.ls.
// See server.Call for documentation.
type Anchor_ls struct {
	*server.Call
}

// Args returns the call's arguments.
func (c Anchor_ls) Args() Anchor_ls_Params {
	return Anchor_ls_Params{Struct: c.Call.Args()}
}

// AllocResults allocates the results struct.
func (c Anchor_ls) AllocResults() (Anchor_ls_Results, error) {
	r, err := c.Call.AllocResults(capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Anchor_ls_Results{Struct: r}, err
}

// Anchor_walk holds the state for a server call to Anchor.walk.
// See server.Call for documentation.
type Anchor_walk struct {
	*server.Call
}

// Args returns the call's arguments.
func (c Anchor_walk) Args() Anchor_walk_Params {
	return Anchor_walk_Params{Struct: c.Call.Args()}
}

// AllocResults allocates the results struct.
func (c Anchor_walk) AllocResults() (Anchor_walk_Results, error) {
	r, err := c.Call.AllocResults(capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Anchor_walk_Results{Struct: r}, err
}

type Anchor_Child struct{ capnp.Struct }

// Anchor_Child_TypeID is the unique identifier for the type Anchor_Child.
const Anchor_Child_TypeID = 0x93b1e8d1781fe71b

func NewAnchor_Child(s *capnp.Segment) (Anchor_Child, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return Anchor_Child{st}, err
}

func NewRootAnchor_Child(s *capnp.Segment) (Anchor_Child, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return Anchor_Child{st}, err
}

func ReadRootAnchor_Child(msg *capnp.Message) (Anchor_Child, error) {
	root, err := msg.Root()
	return Anchor_Child{root.Struct()}, err
}

func (s Anchor_Child) String() string {
	str, _ := text.Marshal(0x93b1e8d1781fe71b, s.Struct)
	return str
}

func (s Anchor_Child) Name() (string, error) {
	p, err := s.Struct.Ptr(0)
	return p.Text(), err
}

func (s Anchor_Child) HasName() bool {
	return s.Struct.HasPtr(0)
}

func (s Anchor_Child) NameBytes() ([]byte, error) {
	p, err := s.Struct.Ptr(0)
	return p.TextBytes(), err
}

func (s Anchor_Child) SetName(v string) error {
	return s.Struct.SetText(0, v)
}

func (s Anchor_Child) Anchor() Anchor {
	p, _ := s.Struct.Ptr(1)
	return Anchor{Client: p.Interface().Client()}
}

func (s Anchor_Child) HasAnchor() bool {
	return s.Struct.HasPtr(1)
}

func (s Anchor_Child) SetAnchor(v Anchor) error {
	if !v.Client.IsValid() {
		return s.Struct.SetPtr(1, capnp.Ptr{})
	}
	seg := s.Segment()
	in := capnp.NewInterface(seg, seg.Message().AddCap(v.Client))
	return s.Struct.SetPtr(1, in.ToPtr())
}

// Anchor_Child_List is a list of Anchor_Child.
type Anchor_Child_List = capnp.StructList[Anchor_Child]

// NewAnchor_Child creates a new list of Anchor_Child.
func NewAnchor_Child_List(s *capnp.Segment, sz int32) (Anchor_Child_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2}, sz)
	return capnp.StructList[Anchor_Child]{List: l}, err
}

// Anchor_Child_Future is a wrapper for a Anchor_Child promised by a client call.
type Anchor_Child_Future struct{ *capnp.Future }

func (p Anchor_Child_Future) Struct() (Anchor_Child, error) {
	s, err := p.Future.Struct()
	return Anchor_Child{s}, err
}

func (p Anchor_Child_Future) Anchor() Anchor {
	return Anchor{Client: p.Future.Field(1, nil).Client()}
}

type Anchor_ls_Params struct{ capnp.Struct }

// Anchor_ls_Params_TypeID is the unique identifier for the type Anchor_ls_Params.
const Anchor_ls_Params_TypeID = 0xece846cc51b6560e

func NewAnchor_ls_Params(s *capnp.Segment) (Anchor_ls_Params, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Anchor_ls_Params{st}, err
}

func NewRootAnchor_ls_Params(s *capnp.Segment) (Anchor_ls_Params, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Anchor_ls_Params{st}, err
}

func ReadRootAnchor_ls_Params(msg *capnp.Message) (Anchor_ls_Params, error) {
	root, err := msg.Root()
	return Anchor_ls_Params{root.Struct()}, err
}

func (s Anchor_ls_Params) String() string {
	str, _ := text.Marshal(0xece846cc51b6560e, s.Struct)
	return str
}

func (s Anchor_ls_Params) Path() (capnp.TextList, error) {
	p, err := s.Struct.Ptr(0)
	return capnp.TextList{List: p.List()}, err
}

func (s Anchor_ls_Params) HasPath() bool {
	return s.Struct.HasPtr(0)
}

func (s Anchor_ls_Params) SetPath(v capnp.TextList) error {
	return s.Struct.SetPtr(0, v.List.ToPtr())
}

// NewPath sets the path field to a newly
// allocated capnp.TextList, preferring placement in s's segment.
func (s Anchor_ls_Params) NewPath(n int32) (capnp.TextList, error) {
	l, err := capnp.NewTextList(s.Struct.Segment(), n)
	if err != nil {
		return capnp.TextList{}, err
	}
	err = s.Struct.SetPtr(0, l.List.ToPtr())
	return l, err
}

// Anchor_ls_Params_List is a list of Anchor_ls_Params.
type Anchor_ls_Params_List = capnp.StructList[Anchor_ls_Params]

// NewAnchor_ls_Params creates a new list of Anchor_ls_Params.
func NewAnchor_ls_Params_List(s *capnp.Segment, sz int32) (Anchor_ls_Params_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return capnp.StructList[Anchor_ls_Params]{List: l}, err
}

// Anchor_ls_Params_Future is a wrapper for a Anchor_ls_Params promised by a client call.
type Anchor_ls_Params_Future struct{ *capnp.Future }

func (p Anchor_ls_Params_Future) Struct() (Anchor_ls_Params, error) {
	s, err := p.Future.Struct()
	return Anchor_ls_Params{s}, err
}

type Anchor_ls_Results struct{ capnp.Struct }

// Anchor_ls_Results_TypeID is the unique identifier for the type Anchor_ls_Results.
const Anchor_ls_Results_TypeID = 0xbc12bdb43837892a

func NewAnchor_ls_Results(s *capnp.Segment) (Anchor_ls_Results, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Anchor_ls_Results{st}, err
}

func NewRootAnchor_ls_Results(s *capnp.Segment) (Anchor_ls_Results, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Anchor_ls_Results{st}, err
}

func ReadRootAnchor_ls_Results(msg *capnp.Message) (Anchor_ls_Results, error) {
	root, err := msg.Root()
	return Anchor_ls_Results{root.Struct()}, err
}

func (s Anchor_ls_Results) String() string {
	str, _ := text.Marshal(0xbc12bdb43837892a, s.Struct)
	return str
}

func (s Anchor_ls_Results) Children() (Anchor_Child_List, error) {
	p, err := s.Struct.Ptr(0)
	return Anchor_Child_List{List: p.List()}, err
}

func (s Anchor_ls_Results) HasChildren() bool {
	return s.Struct.HasPtr(0)
}

func (s Anchor_ls_Results) SetChildren(v Anchor_Child_List) error {
	return s.Struct.SetPtr(0, v.List.ToPtr())
}

// NewChildren sets the children field to a newly
// allocated Anchor_Child_List, preferring placement in s's segment.
func (s Anchor_ls_Results) NewChildren(n int32) (Anchor_Child_List, error) {
	l, err := NewAnchor_Child_List(s.Struct.Segment(), n)
	if err != nil {
		return Anchor_Child_List{}, err
	}
	err = s.Struct.SetPtr(0, l.List.ToPtr())
	return l, err
}

// Anchor_ls_Results_List is a list of Anchor_ls_Results.
type Anchor_ls_Results_List = capnp.StructList[Anchor_ls_Results]

// NewAnchor_ls_Results creates a new list of Anchor_ls_Results.
func NewAnchor_ls_Results_List(s *capnp.Segment, sz int32) (Anchor_ls_Results_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return capnp.StructList[Anchor_ls_Results]{List: l}, err
}

// Anchor_ls_Results_Future is a wrapper for a Anchor_ls_Results promised by a client call.
type Anchor_ls_Results_Future struct{ *capnp.Future }

func (p Anchor_ls_Results_Future) Struct() (Anchor_ls_Results, error) {
	s, err := p.Future.Struct()
	return Anchor_ls_Results{s}, err
}

type Anchor_walk_Params struct{ capnp.Struct }

// Anchor_walk_Params_TypeID is the unique identifier for the type Anchor_walk_Params.
const Anchor_walk_Params_TypeID = 0xb56faa92814c8688

func NewAnchor_walk_Params(s *capnp.Segment) (Anchor_walk_Params, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Anchor_walk_Params{st}, err
}

func NewRootAnchor_walk_Params(s *capnp.Segment) (Anchor_walk_Params, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Anchor_walk_Params{st}, err
}

func ReadRootAnchor_walk_Params(msg *capnp.Message) (Anchor_walk_Params, error) {
	root, err := msg.Root()
	return Anchor_walk_Params{root.Struct()}, err
}

func (s Anchor_walk_Params) String() string {
	str, _ := text.Marshal(0xb56faa92814c8688, s.Struct)
	return str
}

func (s Anchor_walk_Params) Path() (capnp.TextList, error) {
	p, err := s.Struct.Ptr(0)
	return capnp.TextList{List: p.List()}, err
}

func (s Anchor_walk_Params) HasPath() bool {
	return s.Struct.HasPtr(0)
}

func (s Anchor_walk_Params) SetPath(v capnp.TextList) error {
	return s.Struct.SetPtr(0, v.List.ToPtr())
}

// NewPath sets the path field to a newly
// allocated capnp.TextList, preferring placement in s's segment.
func (s Anchor_walk_Params) NewPath(n int32) (capnp.TextList, error) {
	l, err := capnp.NewTextList(s.Struct.Segment(), n)
	if err != nil {
		return capnp.TextList{}, err
	}
	err = s.Struct.SetPtr(0, l.List.ToPtr())
	return l, err
}

// Anchor_walk_Params_List is a list of Anchor_walk_Params.
type Anchor_walk_Params_List = capnp.StructList[Anchor_walk_Params]

// NewAnchor_walk_Params creates a new list of Anchor_walk_Params.
func NewAnchor_walk_Params_List(s *capnp.Segment, sz int32) (Anchor_walk_Params_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return capnp.StructList[Anchor_walk_Params]{List: l}, err
}

// Anchor_walk_Params_Future is a wrapper for a Anchor_walk_Params promised by a client call.
type Anchor_walk_Params_Future struct{ *capnp.Future }

func (p Anchor_walk_Params_Future) Struct() (Anchor_walk_Params, error) {
	s, err := p.Future.Struct()
	return Anchor_walk_Params{s}, err
}

type Anchor_walk_Results struct{ capnp.Struct }

// Anchor_walk_Results_TypeID is the unique identifier for the type Anchor_walk_Results.
const Anchor_walk_Results_TypeID = 0xf74679f5e7457768

func NewAnchor_walk_Results(s *capnp.Segment) (Anchor_walk_Results, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Anchor_walk_Results{st}, err
}

func NewRootAnchor_walk_Results(s *capnp.Segment) (Anchor_walk_Results, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Anchor_walk_Results{st}, err
}

func ReadRootAnchor_walk_Results(msg *capnp.Message) (Anchor_walk_Results, error) {
	root, err := msg.Root()
	return Anchor_walk_Results{root.Struct()}, err
}

func (s Anchor_walk_Results) String() string {
	str, _ := text.Marshal(0xf74679f5e7457768, s.Struct)
	return str
}

func (s Anchor_walk_Results) Anchor() Anchor {
	p, _ := s.Struct.Ptr(0)
	return Anchor{Client: p.Interface().Client()}
}

func (s Anchor_walk_Results) HasAnchor() bool {
	return s.Struct.HasPtr(0)
}

func (s Anchor_walk_Results) SetAnchor(v Anchor) error {
	if !v.Client.IsValid() {
		return s.Struct.SetPtr(0, capnp.Ptr{})
	}
	seg := s.Segment()
	in := capnp.NewInterface(seg, seg.Message().AddCap(v.Client))
	return s.Struct.SetPtr(0, in.ToPtr())
}

// Anchor_walk_Results_List is a list of Anchor_walk_Results.
type Anchor_walk_Results_List = capnp.StructList[Anchor_walk_Results]

// NewAnchor_walk_Results creates a new list of Anchor_walk_Results.
func NewAnchor_walk_Results_List(s *capnp.Segment, sz int32) (Anchor_walk_Results_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return capnp.StructList[Anchor_walk_Results]{List: l}, err
}

// Anchor_walk_Results_Future is a wrapper for a Anchor_walk_Results promised by a client call.
type Anchor_walk_Results_Future struct{ *capnp.Future }

func (p Anchor_walk_Results_Future) Struct() (Anchor_walk_Results, error) {
	s, err := p.Future.Struct()
	return Anchor_walk_Results{s}, err
}

func (p Anchor_walk_Results_Future) Anchor() Anchor {
	return Anchor{Client: p.Future.Field(0, nil).Client()}
}

type Host struct{ Client *capnp.Client }

// Host_TypeID is the unique identifier for the type Host.
const Host_TypeID = 0xf6e7fe32e3eeb18a

func (c Host) Join(ctx context.Context, params func(Host_join_Params) error) (Host_join_Results_Future, capnp.ReleaseFunc) {
	s := capnp.Send{
		Method: capnp.Method{
			InterfaceID:   0xf6e7fe32e3eeb18a,
			MethodID:      0,
			InterfaceName: "anchor.capnp:Host",
			MethodName:    "join",
		},
	}
	if params != nil {
		s.ArgsSize = capnp.ObjectSize{DataSize: 0, PointerCount: 1}
		s.PlaceArgs = func(s capnp.Struct) error { return params(Host_join_Params{Struct: s}) }
	}
	ans, release := c.Client.SendCall(ctx, s)
	return Host_join_Results_Future{Future: ans.Future()}, release
}
func (c Host) Ls(ctx context.Context, params func(Anchor_ls_Params) error) (Anchor_ls_Results_Future, capnp.ReleaseFunc) {
	s := capnp.Send{
		Method: capnp.Method{
			InterfaceID:   0xaebf015e04f2d0ad,
			MethodID:      0,
			InterfaceName: "anchor.capnp:Anchor",
			MethodName:    "ls",
		},
	}
	if params != nil {
		s.ArgsSize = capnp.ObjectSize{DataSize: 0, PointerCount: 1}
		s.PlaceArgs = func(s capnp.Struct) error { return params(Anchor_ls_Params{Struct: s}) }
	}
	ans, release := c.Client.SendCall(ctx, s)
	return Anchor_ls_Results_Future{Future: ans.Future()}, release
}
func (c Host) Walk(ctx context.Context, params func(Anchor_walk_Params) error) (Anchor_walk_Results_Future, capnp.ReleaseFunc) {
	s := capnp.Send{
		Method: capnp.Method{
			InterfaceID:   0xaebf015e04f2d0ad,
			MethodID:      1,
			InterfaceName: "anchor.capnp:Anchor",
			MethodName:    "walk",
		},
	}
	if params != nil {
		s.ArgsSize = capnp.ObjectSize{DataSize: 0, PointerCount: 1}
		s.PlaceArgs = func(s capnp.Struct) error { return params(Anchor_walk_Params{Struct: s}) }
	}
	ans, release := c.Client.SendCall(ctx, s)
	return Anchor_walk_Results_Future{Future: ans.Future()}, release
}

func (c Host) AddRef() Host {
	return Host{
		Client: c.Client.AddRef(),
	}
}

func (c Host) Release() {
	c.Client.Release()
}

// A Host_Server is a Host with a local implementation.
type Host_Server interface {
	Join(context.Context, Host_join) error

	Ls(context.Context, Anchor_ls) error

	Walk(context.Context, Anchor_walk) error
}

// Host_NewServer creates a new Server from an implementation of Host_Server.
func Host_NewServer(s Host_Server, policy *server.Policy) *server.Server {
	c, _ := s.(server.Shutdowner)
	return server.New(Host_Methods(nil, s), s, c, policy)
}

// Host_ServerToClient creates a new Client from an implementation of Host_Server.
// The caller is responsible for calling Release on the returned Client.
func Host_ServerToClient(s Host_Server, policy *server.Policy) Host {
	return Host{Client: capnp.NewClient(Host_NewServer(s, policy))}
}

// Host_Methods appends Methods to a slice that invoke the methods on s.
// This can be used to create a more complicated Server.
func Host_Methods(methods []server.Method, s Host_Server) []server.Method {
	if cap(methods) == 0 {
		methods = make([]server.Method, 0, 3)
	}

	methods = append(methods, server.Method{
		Method: capnp.Method{
			InterfaceID:   0xf6e7fe32e3eeb18a,
			MethodID:      0,
			InterfaceName: "anchor.capnp:Host",
			MethodName:    "join",
		},
		Impl: func(ctx context.Context, call *server.Call) error {
			return s.Join(ctx, Host_join{call})
		},
	})

	methods = append(methods, server.Method{
		Method: capnp.Method{
			InterfaceID:   0xaebf015e04f2d0ad,
			MethodID:      0,
			InterfaceName: "anchor.capnp:Anchor",
			MethodName:    "ls",
		},
		Impl: func(ctx context.Context, call *server.Call) error {
			return s.Ls(ctx, Anchor_ls{call})
		},
	})

	methods = append(methods, server.Method{
		Method: capnp.Method{
			InterfaceID:   0xaebf015e04f2d0ad,
			MethodID:      1,
			InterfaceName: "anchor.capnp:Anchor",
			MethodName:    "walk",
		},
		Impl: func(ctx context.Context, call *server.Call) error {
			return s.Walk(ctx, Anchor_walk{call})
		},
	})

	return methods
}

// Host_join holds the state for a server call to Host.join.
// See server.Call for documentation.
type Host_join struct {
	*server.Call
}

// Args returns the call's arguments.
func (c Host_join) Args() Host_join_Params {
	return Host_join_Params{Struct: c.Call.Args()}
}

// AllocResults allocates the results struct.
func (c Host_join) AllocResults() (Host_join_Results, error) {
	r, err := c.Call.AllocResults(capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return Host_join_Results{Struct: r}, err
}

type Host_AddrInfo struct{ capnp.Struct }

// Host_AddrInfo_TypeID is the unique identifier for the type Host_AddrInfo.
const Host_AddrInfo_TypeID = 0xa51b998d3ce3d226

func NewHost_AddrInfo(s *capnp.Segment) (Host_AddrInfo, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return Host_AddrInfo{st}, err
}

func NewRootHost_AddrInfo(s *capnp.Segment) (Host_AddrInfo, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return Host_AddrInfo{st}, err
}

func ReadRootHost_AddrInfo(msg *capnp.Message) (Host_AddrInfo, error) {
	root, err := msg.Root()
	return Host_AddrInfo{root.Struct()}, err
}

func (s Host_AddrInfo) String() string {
	str, _ := text.Marshal(0xa51b998d3ce3d226, s.Struct)
	return str
}

func (s Host_AddrInfo) Id() (string, error) {
	p, err := s.Struct.Ptr(0)
	return p.Text(), err
}

func (s Host_AddrInfo) HasId() bool {
	return s.Struct.HasPtr(0)
}

func (s Host_AddrInfo) IdBytes() ([]byte, error) {
	p, err := s.Struct.Ptr(0)
	return p.TextBytes(), err
}

func (s Host_AddrInfo) SetId(v string) error {
	return s.Struct.SetText(0, v)
}

func (s Host_AddrInfo) Addrs() (capnp.DataList, error) {
	p, err := s.Struct.Ptr(1)
	return capnp.DataList{List: p.List()}, err
}

func (s Host_AddrInfo) HasAddrs() bool {
	return s.Struct.HasPtr(1)
}

func (s Host_AddrInfo) SetAddrs(v capnp.DataList) error {
	return s.Struct.SetPtr(1, v.List.ToPtr())
}

// NewAddrs sets the addrs field to a newly
// allocated capnp.DataList, preferring placement in s's segment.
func (s Host_AddrInfo) NewAddrs(n int32) (capnp.DataList, error) {
	l, err := capnp.NewDataList(s.Struct.Segment(), n)
	if err != nil {
		return capnp.DataList{}, err
	}
	err = s.Struct.SetPtr(1, l.List.ToPtr())
	return l, err
}

// Host_AddrInfo_List is a list of Host_AddrInfo.
type Host_AddrInfo_List = capnp.StructList[Host_AddrInfo]

// NewHost_AddrInfo creates a new list of Host_AddrInfo.
func NewHost_AddrInfo_List(s *capnp.Segment, sz int32) (Host_AddrInfo_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2}, sz)
	return capnp.StructList[Host_AddrInfo]{List: l}, err
}

// Host_AddrInfo_Future is a wrapper for a Host_AddrInfo promised by a client call.
type Host_AddrInfo_Future struct{ *capnp.Future }

func (p Host_AddrInfo_Future) Struct() (Host_AddrInfo, error) {
	s, err := p.Future.Struct()
	return Host_AddrInfo{s}, err
}

type Host_join_Params struct{ capnp.Struct }

// Host_join_Params_TypeID is the unique identifier for the type Host_join_Params.
const Host_join_Params_TypeID = 0xbeb596597c13bb42

func NewHost_join_Params(s *capnp.Segment) (Host_join_Params, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Host_join_Params{st}, err
}

func NewRootHost_join_Params(s *capnp.Segment) (Host_join_Params, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Host_join_Params{st}, err
}

func ReadRootHost_join_Params(msg *capnp.Message) (Host_join_Params, error) {
	root, err := msg.Root()
	return Host_join_Params{root.Struct()}, err
}

func (s Host_join_Params) String() string {
	str, _ := text.Marshal(0xbeb596597c13bb42, s.Struct)
	return str
}

func (s Host_join_Params) Peers() (Host_AddrInfo_List, error) {
	p, err := s.Struct.Ptr(0)
	return Host_AddrInfo_List{List: p.List()}, err
}

func (s Host_join_Params) HasPeers() bool {
	return s.Struct.HasPtr(0)
}

func (s Host_join_Params) SetPeers(v Host_AddrInfo_List) error {
	return s.Struct.SetPtr(0, v.List.ToPtr())
}

// NewPeers sets the peers field to a newly
// allocated Host_AddrInfo_List, preferring placement in s's segment.
func (s Host_join_Params) NewPeers(n int32) (Host_AddrInfo_List, error) {
	l, err := NewHost_AddrInfo_List(s.Struct.Segment(), n)
	if err != nil {
		return Host_AddrInfo_List{}, err
	}
	err = s.Struct.SetPtr(0, l.List.ToPtr())
	return l, err
}

// Host_join_Params_List is a list of Host_join_Params.
type Host_join_Params_List = capnp.StructList[Host_join_Params]

// NewHost_join_Params creates a new list of Host_join_Params.
func NewHost_join_Params_List(s *capnp.Segment, sz int32) (Host_join_Params_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return capnp.StructList[Host_join_Params]{List: l}, err
}

// Host_join_Params_Future is a wrapper for a Host_join_Params promised by a client call.
type Host_join_Params_Future struct{ *capnp.Future }

func (p Host_join_Params_Future) Struct() (Host_join_Params, error) {
	s, err := p.Future.Struct()
	return Host_join_Params{s}, err
}

type Host_join_Results struct{ capnp.Struct }

// Host_join_Results_TypeID is the unique identifier for the type Host_join_Results.
const Host_join_Results_TypeID = 0xacad6b3a2c0b16a1

func NewHost_join_Results(s *capnp.Segment) (Host_join_Results, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return Host_join_Results{st}, err
}

func NewRootHost_join_Results(s *capnp.Segment) (Host_join_Results, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return Host_join_Results{st}, err
}

func ReadRootHost_join_Results(msg *capnp.Message) (Host_join_Results, error) {
	root, err := msg.Root()
	return Host_join_Results{root.Struct()}, err
}

func (s Host_join_Results) String() string {
	str, _ := text.Marshal(0xacad6b3a2c0b16a1, s.Struct)
	return str
}

// Host_join_Results_List is a list of Host_join_Results.
type Host_join_Results_List = capnp.StructList[Host_join_Results]

// NewHost_join_Results creates a new list of Host_join_Results.
func NewHost_join_Results_List(s *capnp.Segment, sz int32) (Host_join_Results_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0}, sz)
	return capnp.StructList[Host_join_Results]{List: l}, err
}

// Host_join_Results_Future is a wrapper for a Host_join_Results promised by a client call.
type Host_join_Results_Future struct{ *capnp.Future }

func (p Host_join_Results_Future) Struct() (Host_join_Results, error) {
	s, err := p.Future.Struct()
	return Host_join_Results{s}, err
}

type Container struct{ Client *capnp.Client }

// Container_TypeID is the unique identifier for the type Container.
const Container_TypeID = 0x8cf4f24e7ff95270

func (c Container) Get(ctx context.Context, params func(Container_get_Params) error) (Container_get_Results_Future, capnp.ReleaseFunc) {
	s := capnp.Send{
		Method: capnp.Method{
			InterfaceID:   0x8cf4f24e7ff95270,
			MethodID:      0,
			InterfaceName: "anchor.capnp:Container",
			MethodName:    "get",
		},
	}
	if params != nil {
		s.ArgsSize = capnp.ObjectSize{DataSize: 0, PointerCount: 0}
		s.PlaceArgs = func(s capnp.Struct) error { return params(Container_get_Params{Struct: s}) }
	}
	ans, release := c.Client.SendCall(ctx, s)
	return Container_get_Results_Future{Future: ans.Future()}, release
}
func (c Container) Set(ctx context.Context, params func(Container_set_Params) error) (Container_set_Results_Future, capnp.ReleaseFunc) {
	s := capnp.Send{
		Method: capnp.Method{
			InterfaceID:   0x8cf4f24e7ff95270,
			MethodID:      1,
			InterfaceName: "anchor.capnp:Container",
			MethodName:    "set",
		},
	}
	if params != nil {
		s.ArgsSize = capnp.ObjectSize{DataSize: 0, PointerCount: 1}
		s.PlaceArgs = func(s capnp.Struct) error { return params(Container_set_Params{Struct: s}) }
	}
	ans, release := c.Client.SendCall(ctx, s)
	return Container_set_Results_Future{Future: ans.Future()}, release
}
func (c Container) Ls(ctx context.Context, params func(Anchor_ls_Params) error) (Anchor_ls_Results_Future, capnp.ReleaseFunc) {
	s := capnp.Send{
		Method: capnp.Method{
			InterfaceID:   0xaebf015e04f2d0ad,
			MethodID:      0,
			InterfaceName: "anchor.capnp:Anchor",
			MethodName:    "ls",
		},
	}
	if params != nil {
		s.ArgsSize = capnp.ObjectSize{DataSize: 0, PointerCount: 1}
		s.PlaceArgs = func(s capnp.Struct) error { return params(Anchor_ls_Params{Struct: s}) }
	}
	ans, release := c.Client.SendCall(ctx, s)
	return Anchor_ls_Results_Future{Future: ans.Future()}, release
}
func (c Container) Walk(ctx context.Context, params func(Anchor_walk_Params) error) (Anchor_walk_Results_Future, capnp.ReleaseFunc) {
	s := capnp.Send{
		Method: capnp.Method{
			InterfaceID:   0xaebf015e04f2d0ad,
			MethodID:      1,
			InterfaceName: "anchor.capnp:Anchor",
			MethodName:    "walk",
		},
	}
	if params != nil {
		s.ArgsSize = capnp.ObjectSize{DataSize: 0, PointerCount: 1}
		s.PlaceArgs = func(s capnp.Struct) error { return params(Anchor_walk_Params{Struct: s}) }
	}
	ans, release := c.Client.SendCall(ctx, s)
	return Anchor_walk_Results_Future{Future: ans.Future()}, release
}

func (c Container) AddRef() Container {
	return Container{
		Client: c.Client.AddRef(),
	}
}

func (c Container) Release() {
	c.Client.Release()
}

// A Container_Server is a Container with a local implementation.
type Container_Server interface {
	Get(context.Context, Container_get) error

	Set(context.Context, Container_set) error

	Ls(context.Context, Anchor_ls) error

	Walk(context.Context, Anchor_walk) error
}

// Container_NewServer creates a new Server from an implementation of Container_Server.
func Container_NewServer(s Container_Server, policy *server.Policy) *server.Server {
	c, _ := s.(server.Shutdowner)
	return server.New(Container_Methods(nil, s), s, c, policy)
}

// Container_ServerToClient creates a new Client from an implementation of Container_Server.
// The caller is responsible for calling Release on the returned Client.
func Container_ServerToClient(s Container_Server, policy *server.Policy) Container {
	return Container{Client: capnp.NewClient(Container_NewServer(s, policy))}
}

// Container_Methods appends Methods to a slice that invoke the methods on s.
// This can be used to create a more complicated Server.
func Container_Methods(methods []server.Method, s Container_Server) []server.Method {
	if cap(methods) == 0 {
		methods = make([]server.Method, 0, 4)
	}

	methods = append(methods, server.Method{
		Method: capnp.Method{
			InterfaceID:   0x8cf4f24e7ff95270,
			MethodID:      0,
			InterfaceName: "anchor.capnp:Container",
			MethodName:    "get",
		},
		Impl: func(ctx context.Context, call *server.Call) error {
			return s.Get(ctx, Container_get{call})
		},
	})

	methods = append(methods, server.Method{
		Method: capnp.Method{
			InterfaceID:   0x8cf4f24e7ff95270,
			MethodID:      1,
			InterfaceName: "anchor.capnp:Container",
			MethodName:    "set",
		},
		Impl: func(ctx context.Context, call *server.Call) error {
			return s.Set(ctx, Container_set{call})
		},
	})

	methods = append(methods, server.Method{
		Method: capnp.Method{
			InterfaceID:   0xaebf015e04f2d0ad,
			MethodID:      0,
			InterfaceName: "anchor.capnp:Anchor",
			MethodName:    "ls",
		},
		Impl: func(ctx context.Context, call *server.Call) error {
			return s.Ls(ctx, Anchor_ls{call})
		},
	})

	methods = append(methods, server.Method{
		Method: capnp.Method{
			InterfaceID:   0xaebf015e04f2d0ad,
			MethodID:      1,
			InterfaceName: "anchor.capnp:Anchor",
			MethodName:    "walk",
		},
		Impl: func(ctx context.Context, call *server.Call) error {
			return s.Walk(ctx, Anchor_walk{call})
		},
	})

	return methods
}

// Container_get holds the state for a server call to Container.get.
// See server.Call for documentation.
type Container_get struct {
	*server.Call
}

// Args returns the call's arguments.
func (c Container_get) Args() Container_get_Params {
	return Container_get_Params{Struct: c.Call.Args()}
}

// AllocResults allocates the results struct.
func (c Container_get) AllocResults() (Container_get_Results, error) {
	r, err := c.Call.AllocResults(capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Container_get_Results{Struct: r}, err
}

// Container_set holds the state for a server call to Container.set.
// See server.Call for documentation.
type Container_set struct {
	*server.Call
}

// Args returns the call's arguments.
func (c Container_set) Args() Container_set_Params {
	return Container_set_Params{Struct: c.Call.Args()}
}

// AllocResults allocates the results struct.
func (c Container_set) AllocResults() (Container_set_Results, error) {
	r, err := c.Call.AllocResults(capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return Container_set_Results{Struct: r}, err
}

type Container_get_Params struct{ capnp.Struct }

// Container_get_Params_TypeID is the unique identifier for the type Container_get_Params.
const Container_get_Params_TypeID = 0x862aefe951e463b8

func NewContainer_get_Params(s *capnp.Segment) (Container_get_Params, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return Container_get_Params{st}, err
}

func NewRootContainer_get_Params(s *capnp.Segment) (Container_get_Params, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return Container_get_Params{st}, err
}

func ReadRootContainer_get_Params(msg *capnp.Message) (Container_get_Params, error) {
	root, err := msg.Root()
	return Container_get_Params{root.Struct()}, err
}

func (s Container_get_Params) String() string {
	str, _ := text.Marshal(0x862aefe951e463b8, s.Struct)
	return str
}

// Container_get_Params_List is a list of Container_get_Params.
type Container_get_Params_List = capnp.StructList[Container_get_Params]

// NewContainer_get_Params creates a new list of Container_get_Params.
func NewContainer_get_Params_List(s *capnp.Segment, sz int32) (Container_get_Params_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0}, sz)
	return capnp.StructList[Container_get_Params]{List: l}, err
}

// Container_get_Params_Future is a wrapper for a Container_get_Params promised by a client call.
type Container_get_Params_Future struct{ *capnp.Future }

func (p Container_get_Params_Future) Struct() (Container_get_Params, error) {
	s, err := p.Future.Struct()
	return Container_get_Params{s}, err
}

type Container_get_Results struct{ capnp.Struct }

// Container_get_Results_TypeID is the unique identifier for the type Container_get_Results.
const Container_get_Results_TypeID = 0xadfb4ab15dd87a80

func NewContainer_get_Results(s *capnp.Segment) (Container_get_Results, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Container_get_Results{st}, err
}

func NewRootContainer_get_Results(s *capnp.Segment) (Container_get_Results, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Container_get_Results{st}, err
}

func ReadRootContainer_get_Results(msg *capnp.Message) (Container_get_Results, error) {
	root, err := msg.Root()
	return Container_get_Results{root.Struct()}, err
}

func (s Container_get_Results) String() string {
	str, _ := text.Marshal(0xadfb4ab15dd87a80, s.Struct)
	return str
}

func (s Container_get_Results) Data() ([]byte, error) {
	p, err := s.Struct.Ptr(0)
	return []byte(p.Data()), err
}

func (s Container_get_Results) HasData() bool {
	return s.Struct.HasPtr(0)
}

func (s Container_get_Results) SetData(v []byte) error {
	return s.Struct.SetData(0, v)
}

// Container_get_Results_List is a list of Container_get_Results.
type Container_get_Results_List = capnp.StructList[Container_get_Results]

// NewContainer_get_Results creates a new list of Container_get_Results.
func NewContainer_get_Results_List(s *capnp.Segment, sz int32) (Container_get_Results_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return capnp.StructList[Container_get_Results]{List: l}, err
}

// Container_get_Results_Future is a wrapper for a Container_get_Results promised by a client call.
type Container_get_Results_Future struct{ *capnp.Future }

func (p Container_get_Results_Future) Struct() (Container_get_Results, error) {
	s, err := p.Future.Struct()
	return Container_get_Results{s}, err
}

type Container_set_Params struct{ capnp.Struct }

// Container_set_Params_TypeID is the unique identifier for the type Container_set_Params.
const Container_set_Params_TypeID = 0x95c3bb398eff8c7e

func NewContainer_set_Params(s *capnp.Segment) (Container_set_Params, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Container_set_Params{st}, err
}

func NewRootContainer_set_Params(s *capnp.Segment) (Container_set_Params, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Container_set_Params{st}, err
}

func ReadRootContainer_set_Params(msg *capnp.Message) (Container_set_Params, error) {
	root, err := msg.Root()
	return Container_set_Params{root.Struct()}, err
}

func (s Container_set_Params) String() string {
	str, _ := text.Marshal(0x95c3bb398eff8c7e, s.Struct)
	return str
}

func (s Container_set_Params) Data() ([]byte, error) {
	p, err := s.Struct.Ptr(0)
	return []byte(p.Data()), err
}

func (s Container_set_Params) HasData() bool {
	return s.Struct.HasPtr(0)
}

func (s Container_set_Params) SetData(v []byte) error {
	return s.Struct.SetData(0, v)
}

// Container_set_Params_List is a list of Container_set_Params.
type Container_set_Params_List = capnp.StructList[Container_set_Params]

// NewContainer_set_Params creates a new list of Container_set_Params.
func NewContainer_set_Params_List(s *capnp.Segment, sz int32) (Container_set_Params_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return capnp.StructList[Container_set_Params]{List: l}, err
}

// Container_set_Params_Future is a wrapper for a Container_set_Params promised by a client call.
type Container_set_Params_Future struct{ *capnp.Future }

func (p Container_set_Params_Future) Struct() (Container_set_Params, error) {
	s, err := p.Future.Struct()
	return Container_set_Params{s}, err
}

type Container_set_Results struct{ capnp.Struct }

// Container_set_Results_TypeID is the unique identifier for the type Container_set_Results.
const Container_set_Results_TypeID = 0xf21ac7b45533c780

func NewContainer_set_Results(s *capnp.Segment) (Container_set_Results, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return Container_set_Results{st}, err
}

func NewRootContainer_set_Results(s *capnp.Segment) (Container_set_Results, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return Container_set_Results{st}, err
}

func ReadRootContainer_set_Results(msg *capnp.Message) (Container_set_Results, error) {
	root, err := msg.Root()
	return Container_set_Results{root.Struct()}, err
}

func (s Container_set_Results) String() string {
	str, _ := text.Marshal(0xf21ac7b45533c780, s.Struct)
	return str
}

// Container_set_Results_List is a list of Container_set_Results.
type Container_set_Results_List = capnp.StructList[Container_set_Results]

// NewContainer_set_Results creates a new list of Container_set_Results.
func NewContainer_set_Results_List(s *capnp.Segment, sz int32) (Container_set_Results_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0}, sz)
	return capnp.StructList[Container_set_Results]{List: l}, err
}

// Container_set_Results_Future is a wrapper for a Container_set_Results promised by a client call.
type Container_set_Results_Future struct{ *capnp.Future }

func (p Container_set_Results_Future) Struct() (Container_set_Results, error) {
	s, err := p.Future.Struct()
	return Container_set_Results{s}, err
}

const schema_c60caf5632fce538 = "x\xda\x94T]h#U\x14>g\xee\x9d\x9dE\x93" +
	"f\xa7\xb7Z\x92e\x89H\x945\xd8\xb2\xcd\x0a\xaeA" +
	"I\xd6u\xd7\xb5\xac\x92\x09\xb8\xd0\x07\x85!3\xbb\x89" +
	"\x9b\xce\xc4\xcc,U\xf1g\xf7eW\xa5*T*\xf8" +
	"\xe0\x83B_\xc4(\x81V\xc4Z}\x90\xda\x17\x1f\xb4" +
	"O\xe2\x9b\xd4\xd2\x0a\xfe`\xf0\x07\xab8rgr3" +
	"cL\x8b\xfbR\x9a\x9c\x93\xef\xfb\xce\xf9\xbe{\x8e\xdc" +
	"$\x15\xe9D\xfc\x95} ig\xe4}\xde\x07\x95o" +
	"\xb5\xef~\xca^\x01u\x14\x01\xa8\x02pt\x8c\x0c#" +
	"P\xafQ\xfe\xe3\xb9\x87:\xbf\xcc\x82\x1a'\xde\xb1\xcd" +
	"\xbfrg\xdf\x8b}\x06\x80\xec\x06\xf2!;D\x14\x00" +
	"\x96$WY\x8d\x8c\x02x\x07\xb7\xd2O|\xb9\xdd~" +
	"\x15\xd4\x11\xf4Z_t\xe8\xa3\xf8\xc9\xbb K\xbck" +
	"\x8a\xac3\xd3\xef\xd7\xc9\x0c\xa0\xf7\xec\xac\xf7\xf2]\xcb" +
	"\x9f\xce\x07\x942r\xce\x15\xce\x89l\x95\x14\x00\xbd[" +
	"\xd77\xee~\xe9\xf5\x83\x0b\xa0\x0e\xa3\xf7b\xfb\xc7\x8d" +
	"\xdc\xdf[\xbfu\xc16\xc9\xd7\xecg\x1f\xec\x07\x1f\xec" +
	"\xcd\x1b\xaf\xbf=\x7f\xa1\xf5\x0e\xef\x0d\xf4\xb3)\xba\x03" +
	"\xd4\xbb\xf4\xd4W\x8f\xb4'\xfflEY\xee\xa1)\xce" +
	"r\x92r\x96\x9e\xca\xfe\xf9L\xfa\x16\x9b\xa6\xa3\x00\xec" +
	"\"\xbd\xcaV9\xa6\xf7\xfc\x953\x97\xe7\xde\xb6\x97\xf8" +
	"|\x02\xadE%\x8e\xd6\xf6\xd1\xb2/\xdcylqe" +
	"\xf8\xa3H\x03\xfb\x86\xee\x00\xb2M\xbf~\xef2{z" +
	"\xea\xb5\xa5\x8f\x03\x9dA=)w\x00\xd9!\x99\xd7\x87" +
	"\xce\xbe\xaf}~j\xfb\xfb\xe8\xef\x1f\xf4\xeb\x9a_\xbf" +
	"\xb4v\xf4\xe1\xc5\xb5T'\xe2\xd3e9\xc5}\xea-" +
	"\xa8\x7f\x8e\x9a<\xc7\x1e\x97\xf9\x1c\xcf\xc8\xf7\xb3\x05\xfe" +
	"\x9fW\x9d9\xb9\xf5\xeb\x93\xa7~\x8f\xce1/_\xc7" +
	"\xe7xC.\xc0\x98\xa7[\x95\xaa\xdd\x1c\xaf\x10\xbda" +
	"5\xf2'l\xcb\xd5k\x96\xd9\x1c?o\xba\x99\x92\xde" +
	"\xd4\xa7\xd1\xe9\xf5\xa0\xe8)\x04M%Dm?\x91\x01" +
	"z\xa9B\xe1\x82:q3H\xea-\x0a\x86\xf6\xa3\x18" +
	"IM\xf2Z\\Q\xce\x9bn\x11\x15\x87\xff\xd5(F" +
	"\x1c\x02\xe8qJ>\xe7\xf1\xe0\xd3\x89j\xad\x8eF@" +
	"K\x01(\x02\xa8\xb7e\x01\xb4\x0cA\xed\x88\x84*\xe2" +
	"\x08\xf2/\xc7\xf2\x00\xdaa\x82\xda\x1d\x12&,}\xda" +
	"\xc4\x18H\x18\x03,\x04\xb8\xa8F\xc8\x10U\xc0]\x17" +
	"\xe1\x84\x8b\xd0h\x8f5\xceY\xf7\x13\xd4F$L\x18" +
	"\xba\xabc\x1c$\x8cGp\x02\xe1\xa7m\xc7\x1d?n" +
	"\x18\xcd\x07,r\xce\xeeS\x9e\x1a\xa4<\xd7U~\x9f" +
	"\x84\xa4f\x08\xddi\xdd0\x9a\x0e\x0e\x01\x96\x08\xfa\\" +
	"C\x83\xb9\x1e\xb3kV\xa6\\0\x9d\x8bu\xd7\xd9\xd3" +
	"\xdd2\xef!\xee\xb5M\x85\xc2\x0e\xa5j7}\xd3\xc2" +
	"K\x80\xb947\xc8\xe8fB$\x1c\xc5SQ'R" +
	"\"\x13\xe2y\xa1\xc8\xa7\x9a\xcc\xfa\x99 u\xa7\x88\x89" +
	"\x19\xbd~\xa1\x88%\xecw\xa5\x1b\x03^\x0e<q`" +
	"\x90\xfa\x8c\x84\x89\x86\xeeV\xc5\xbab\x03\xd7\xd5\x05\xab" +
	";\xbduE\xb1&\x01\xb4\x18A\xed\xb0\x84^\x85O" +
	"\xd54-\x00\x10\x90\x07\xc2\xb9\x01\xf7\xf4\xa2\x94\xf6\x85" +
	"F\xb1s\xa1\xcet\xc34C_\x0f\x84\xa7p j" +
	"(y\x00\xea\xff\x9d~P\xc0E\x16\xfa|>m;" +
	"\xe8\xfa.\x87'\x1a'\xbd \xcf\xe7l\x00\xbe~\xee" +
	"\xb5\xb8v(\xce\xb3\xaar?e%\xc1w\xb0\xc7\xf3" +
	"\xfe\xaf\xaf\xe5\xc0\x0b\xf8\x97\xb3\xf90\x97\xbb\xbe\xe0\x7f" +
	"\x02\x00\x00\xff\xff\x0a!\xe0\x0a"

func init() {
	schemas.Register(schema_c60caf5632fce538,
		0x862aefe951e463b8,
		0x8cf4f24e7ff95270,
		0x93b1e8d1781fe71b,
		0x95c3bb398eff8c7e,
		0xa51b998d3ce3d226,
		0xacad6b3a2c0b16a1,
		0xadfb4ab15dd87a80,
		0xaebf015e04f2d0ad,
		0xb56faa92814c8688,
		0xbc12bdb43837892a,
		0xbeb596597c13bb42,
		0xece846cc51b6560e,
		0xf21ac7b45533c780,
		0xf6e7fe32e3eeb18a,
		0xf74679f5e7457768)
}
