// Code generated by capnpc-go. DO NOT EDIT.

package channel

import (
	capnp "capnproto.org/go/capnp/v3"
	text "capnproto.org/go/capnp/v3/encoding/text"
	fc "capnproto.org/go/capnp/v3/flowcontrol"
	schemas "capnproto.org/go/capnp/v3/schemas"
	server "capnproto.org/go/capnp/v3/server"
	context "context"
)

type Closer capnp.Client

// Closer_TypeID is the unique identifier for the type Closer.
const Closer_TypeID = 0xfad0e4b80d3779c3

func (c Closer) Close(ctx context.Context, params func(Closer_close_Params) error) (Closer_close_Results_Future, capnp.ReleaseFunc) {

	s := capnp.Send{
		Method: capnp.Method{
			InterfaceID:   0xfad0e4b80d3779c3,
			MethodID:      0,
			InterfaceName: "channel.capnp:Closer",
			MethodName:    "close",
		},
	}
	if params != nil {
		s.ArgsSize = capnp.ObjectSize{DataSize: 0, PointerCount: 0}
		s.PlaceArgs = func(s capnp.Struct) error { return params(Closer_close_Params(s)) }
	}

	ans, release := capnp.Client(c).SendCall(ctx, s)
	return Closer_close_Results_Future{Future: ans.Future()}, release

}

func (c Closer) WaitStreaming() error {
	return capnp.Client(c).WaitStreaming()
}

// String returns a string that identifies this capability for debugging
// purposes.  Its format should not be depended on: in particular, it
// should not be used to compare clients.  Use IsSame to compare clients
// for equality.
func (c Closer) String() string {
	return "Closer(" + capnp.Client(c).String() + ")"
}

// AddRef creates a new Client that refers to the same capability as c.
// If c is nil or has resolved to null, then AddRef returns nil.
func (c Closer) AddRef() Closer {
	return Closer(capnp.Client(c).AddRef())
}

// Release releases a capability reference.  If this is the last
// reference to the capability, then the underlying resources associated
// with the capability will be released.
//
// Release will panic if c has already been released, but not if c is
// nil or resolved to null.
func (c Closer) Release() {
	capnp.Client(c).Release()
}

// Resolve blocks until the capability is fully resolved or the Context
// expires.
func (c Closer) Resolve(ctx context.Context) error {
	return capnp.Client(c).Resolve(ctx)
}

func (c Closer) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Client(c).EncodeAsPtr(seg)
}

func (Closer) DecodeFromPtr(p capnp.Ptr) Closer {
	return Closer(capnp.Client{}.DecodeFromPtr(p))
}

// IsValid reports whether c is a valid reference to a capability.
// A reference is invalid if it is nil, has resolved to null, or has
// been released.
func (c Closer) IsValid() bool {
	return capnp.Client(c).IsValid()
}

// IsSame reports whether c and other refer to a capability created by the
// same call to NewClient.  This can return false negatives if c or other
// are not fully resolved: use Resolve if this is an issue.  If either
// c or other are released, then IsSame panics.
func (c Closer) IsSame(other Closer) bool {
	return capnp.Client(c).IsSame(capnp.Client(other))
}

// Update the flowcontrol.FlowLimiter used to manage flow control for
// this client. This affects all future calls, but not calls already
// waiting to send. Passing nil sets the value to flowcontrol.NopLimiter,
// which is also the default.
func (c Closer) SetFlowLimiter(lim fc.FlowLimiter) {
	capnp.Client(c).SetFlowLimiter(lim)
}

// Get the current flowcontrol.FlowLimiter used to manage flow control
// for this client.
func (c Closer) GetFlowLimiter() fc.FlowLimiter {
	return capnp.Client(c).GetFlowLimiter()
}

// A Closer_Server is a Closer with a local implementation.
type Closer_Server interface {
	Close(context.Context, Closer_close) error
}

// Closer_NewServer creates a new Server from an implementation of Closer_Server.
func Closer_NewServer(s Closer_Server) *server.Server {
	c, _ := s.(server.Shutdowner)
	return server.New(Closer_Methods(nil, s), s, c)
}

// Closer_ServerToClient creates a new Client from an implementation of Closer_Server.
// The caller is responsible for calling Release on the returned Client.
func Closer_ServerToClient(s Closer_Server) Closer {
	return Closer(capnp.NewClient(Closer_NewServer(s)))
}

// Closer_Methods appends Methods to a slice that invoke the methods on s.
// This can be used to create a more complicated Server.
func Closer_Methods(methods []server.Method, s Closer_Server) []server.Method {
	if cap(methods) == 0 {
		methods = make([]server.Method, 0, 1)
	}

	methods = append(methods, server.Method{
		Method: capnp.Method{
			InterfaceID:   0xfad0e4b80d3779c3,
			MethodID:      0,
			InterfaceName: "channel.capnp:Closer",
			MethodName:    "close",
		},
		Impl: func(ctx context.Context, call *server.Call) error {
			return s.Close(ctx, Closer_close{call})
		},
	})

	return methods
}

// Closer_close holds the state for a server call to Closer.close.
// See server.Call for documentation.
type Closer_close struct {
	*server.Call
}

// Args returns the call's arguments.
func (c Closer_close) Args() Closer_close_Params {
	return Closer_close_Params(c.Call.Args())
}

// AllocResults allocates the results struct.
func (c Closer_close) AllocResults() (Closer_close_Results, error) {
	r, err := c.Call.AllocResults(capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return Closer_close_Results(r), err
}

// Closer_List is a list of Closer.
type Closer_List = capnp.CapList[Closer]

// NewCloser creates a new list of Closer.
func NewCloser_List(s *capnp.Segment, sz int32) (Closer_List, error) {
	l, err := capnp.NewPointerList(s, sz)
	return capnp.CapList[Closer](l), err
}

type Closer_close_Params capnp.Struct

// Closer_close_Params_TypeID is the unique identifier for the type Closer_close_Params.
const Closer_close_Params_TypeID = 0xfd07d8a1cc36583c

func NewCloser_close_Params(s *capnp.Segment) (Closer_close_Params, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return Closer_close_Params(st), err
}

func NewRootCloser_close_Params(s *capnp.Segment) (Closer_close_Params, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return Closer_close_Params(st), err
}

func ReadRootCloser_close_Params(msg *capnp.Message) (Closer_close_Params, error) {
	root, err := msg.Root()
	return Closer_close_Params(root.Struct()), err
}

func (s Closer_close_Params) String() string {
	str, _ := text.Marshal(0xfd07d8a1cc36583c, capnp.Struct(s))
	return str
}

func (s Closer_close_Params) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Closer_close_Params) DecodeFromPtr(p capnp.Ptr) Closer_close_Params {
	return Closer_close_Params(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Closer_close_Params) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Closer_close_Params) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Closer_close_Params) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Closer_close_Params) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}

// Closer_close_Params_List is a list of Closer_close_Params.
type Closer_close_Params_List = capnp.StructList[Closer_close_Params]

// NewCloser_close_Params creates a new list of Closer_close_Params.
func NewCloser_close_Params_List(s *capnp.Segment, sz int32) (Closer_close_Params_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0}, sz)
	return capnp.StructList[Closer_close_Params](l), err
}

// Closer_close_Params_Future is a wrapper for a Closer_close_Params promised by a client call.
type Closer_close_Params_Future struct{ *capnp.Future }

func (f Closer_close_Params_Future) Struct() (Closer_close_Params, error) {
	p, err := f.Future.Ptr()
	return Closer_close_Params(p.Struct()), err
}

type Closer_close_Results capnp.Struct

// Closer_close_Results_TypeID is the unique identifier for the type Closer_close_Results.
const Closer_close_Results_TypeID = 0xcbee5caf8b7af4ea

func NewCloser_close_Results(s *capnp.Segment) (Closer_close_Results, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return Closer_close_Results(st), err
}

func NewRootCloser_close_Results(s *capnp.Segment) (Closer_close_Results, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return Closer_close_Results(st), err
}

func ReadRootCloser_close_Results(msg *capnp.Message) (Closer_close_Results, error) {
	root, err := msg.Root()
	return Closer_close_Results(root.Struct()), err
}

func (s Closer_close_Results) String() string {
	str, _ := text.Marshal(0xcbee5caf8b7af4ea, capnp.Struct(s))
	return str
}

func (s Closer_close_Results) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Closer_close_Results) DecodeFromPtr(p capnp.Ptr) Closer_close_Results {
	return Closer_close_Results(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Closer_close_Results) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Closer_close_Results) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Closer_close_Results) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Closer_close_Results) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}

// Closer_close_Results_List is a list of Closer_close_Results.
type Closer_close_Results_List = capnp.StructList[Closer_close_Results]

// NewCloser_close_Results creates a new list of Closer_close_Results.
func NewCloser_close_Results_List(s *capnp.Segment, sz int32) (Closer_close_Results_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0}, sz)
	return capnp.StructList[Closer_close_Results](l), err
}

// Closer_close_Results_Future is a wrapper for a Closer_close_Results promised by a client call.
type Closer_close_Results_Future struct{ *capnp.Future }

func (f Closer_close_Results_Future) Struct() (Closer_close_Results, error) {
	p, err := f.Future.Ptr()
	return Closer_close_Results(p.Struct()), err
}

type Sender capnp.Client

// Sender_TypeID is the unique identifier for the type Sender.
const Sender_TypeID = 0xe8bbed1438ea16ee

func (c Sender) Send(ctx context.Context, params func(Sender_send_Params) error) (Sender_send_Results_Future, capnp.ReleaseFunc) {

	s := capnp.Send{
		Method: capnp.Method{
			InterfaceID:   0xe8bbed1438ea16ee,
			MethodID:      0,
			InterfaceName: "channel.capnp:Sender",
			MethodName:    "send",
		},
	}
	if params != nil {
		s.ArgsSize = capnp.ObjectSize{DataSize: 0, PointerCount: 1}
		s.PlaceArgs = func(s capnp.Struct) error { return params(Sender_send_Params(s)) }
	}

	ans, release := capnp.Client(c).SendCall(ctx, s)
	return Sender_send_Results_Future{Future: ans.Future()}, release

}

func (c Sender) WaitStreaming() error {
	return capnp.Client(c).WaitStreaming()
}

// String returns a string that identifies this capability for debugging
// purposes.  Its format should not be depended on: in particular, it
// should not be used to compare clients.  Use IsSame to compare clients
// for equality.
func (c Sender) String() string {
	return "Sender(" + capnp.Client(c).String() + ")"
}

// AddRef creates a new Client that refers to the same capability as c.
// If c is nil or has resolved to null, then AddRef returns nil.
func (c Sender) AddRef() Sender {
	return Sender(capnp.Client(c).AddRef())
}

// Release releases a capability reference.  If this is the last
// reference to the capability, then the underlying resources associated
// with the capability will be released.
//
// Release will panic if c has already been released, but not if c is
// nil or resolved to null.
func (c Sender) Release() {
	capnp.Client(c).Release()
}

// Resolve blocks until the capability is fully resolved or the Context
// expires.
func (c Sender) Resolve(ctx context.Context) error {
	return capnp.Client(c).Resolve(ctx)
}

func (c Sender) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Client(c).EncodeAsPtr(seg)
}

func (Sender) DecodeFromPtr(p capnp.Ptr) Sender {
	return Sender(capnp.Client{}.DecodeFromPtr(p))
}

// IsValid reports whether c is a valid reference to a capability.
// A reference is invalid if it is nil, has resolved to null, or has
// been released.
func (c Sender) IsValid() bool {
	return capnp.Client(c).IsValid()
}

// IsSame reports whether c and other refer to a capability created by the
// same call to NewClient.  This can return false negatives if c or other
// are not fully resolved: use Resolve if this is an issue.  If either
// c or other are released, then IsSame panics.
func (c Sender) IsSame(other Sender) bool {
	return capnp.Client(c).IsSame(capnp.Client(other))
}

// Update the flowcontrol.FlowLimiter used to manage flow control for
// this client. This affects all future calls, but not calls already
// waiting to send. Passing nil sets the value to flowcontrol.NopLimiter,
// which is also the default.
func (c Sender) SetFlowLimiter(lim fc.FlowLimiter) {
	capnp.Client(c).SetFlowLimiter(lim)
}

// Get the current flowcontrol.FlowLimiter used to manage flow control
// for this client.
func (c Sender) GetFlowLimiter() fc.FlowLimiter {
	return capnp.Client(c).GetFlowLimiter()
}

// A Sender_Server is a Sender with a local implementation.
type Sender_Server interface {
	Send(context.Context, Sender_send) error
}

// Sender_NewServer creates a new Server from an implementation of Sender_Server.
func Sender_NewServer(s Sender_Server) *server.Server {
	c, _ := s.(server.Shutdowner)
	return server.New(Sender_Methods(nil, s), s, c)
}

// Sender_ServerToClient creates a new Client from an implementation of Sender_Server.
// The caller is responsible for calling Release on the returned Client.
func Sender_ServerToClient(s Sender_Server) Sender {
	return Sender(capnp.NewClient(Sender_NewServer(s)))
}

// Sender_Methods appends Methods to a slice that invoke the methods on s.
// This can be used to create a more complicated Server.
func Sender_Methods(methods []server.Method, s Sender_Server) []server.Method {
	if cap(methods) == 0 {
		methods = make([]server.Method, 0, 1)
	}

	methods = append(methods, server.Method{
		Method: capnp.Method{
			InterfaceID:   0xe8bbed1438ea16ee,
			MethodID:      0,
			InterfaceName: "channel.capnp:Sender",
			MethodName:    "send",
		},
		Impl: func(ctx context.Context, call *server.Call) error {
			return s.Send(ctx, Sender_send{call})
		},
	})

	return methods
}

// Sender_send holds the state for a server call to Sender.send.
// See server.Call for documentation.
type Sender_send struct {
	*server.Call
}

// Args returns the call's arguments.
func (c Sender_send) Args() Sender_send_Params {
	return Sender_send_Params(c.Call.Args())
}

// AllocResults allocates the results struct.
func (c Sender_send) AllocResults() (Sender_send_Results, error) {
	r, err := c.Call.AllocResults(capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return Sender_send_Results(r), err
}

// Sender_List is a list of Sender.
type Sender_List = capnp.CapList[Sender]

// NewSender creates a new list of Sender.
func NewSender_List(s *capnp.Segment, sz int32) (Sender_List, error) {
	l, err := capnp.NewPointerList(s, sz)
	return capnp.CapList[Sender](l), err
}

type Sender_send_Params capnp.Struct

// Sender_send_Params_TypeID is the unique identifier for the type Sender_send_Params.
const Sender_send_Params_TypeID = 0x8166bc9c3ded78ca

func NewSender_send_Params(s *capnp.Segment) (Sender_send_Params, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Sender_send_Params(st), err
}

func NewRootSender_send_Params(s *capnp.Segment) (Sender_send_Params, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Sender_send_Params(st), err
}

func ReadRootSender_send_Params(msg *capnp.Message) (Sender_send_Params, error) {
	root, err := msg.Root()
	return Sender_send_Params(root.Struct()), err
}

func (s Sender_send_Params) String() string {
	str, _ := text.Marshal(0x8166bc9c3ded78ca, capnp.Struct(s))
	return str
}

func (s Sender_send_Params) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Sender_send_Params) DecodeFromPtr(p capnp.Ptr) Sender_send_Params {
	return Sender_send_Params(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Sender_send_Params) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Sender_send_Params) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Sender_send_Params) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Sender_send_Params) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Sender_send_Params) Value() (capnp.Ptr, error) {
	return capnp.Struct(s).Ptr(0)
}

func (s Sender_send_Params) HasValue() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s Sender_send_Params) SetValue(v capnp.Ptr) error {
	return capnp.Struct(s).SetPtr(0, v)
}

// Sender_send_Params_List is a list of Sender_send_Params.
type Sender_send_Params_List = capnp.StructList[Sender_send_Params]

// NewSender_send_Params creates a new list of Sender_send_Params.
func NewSender_send_Params_List(s *capnp.Segment, sz int32) (Sender_send_Params_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return capnp.StructList[Sender_send_Params](l), err
}

// Sender_send_Params_Future is a wrapper for a Sender_send_Params promised by a client call.
type Sender_send_Params_Future struct{ *capnp.Future }

func (f Sender_send_Params_Future) Struct() (Sender_send_Params, error) {
	p, err := f.Future.Ptr()
	return Sender_send_Params(p.Struct()), err
}
func (p Sender_send_Params_Future) Value() *capnp.Future {
	return p.Future.Field(0, nil)
}

type Sender_send_Results capnp.Struct

// Sender_send_Results_TypeID is the unique identifier for the type Sender_send_Results.
const Sender_send_Results_TypeID = 0xbb3101eccc20b4eb

func NewSender_send_Results(s *capnp.Segment) (Sender_send_Results, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return Sender_send_Results(st), err
}

func NewRootSender_send_Results(s *capnp.Segment) (Sender_send_Results, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return Sender_send_Results(st), err
}

func ReadRootSender_send_Results(msg *capnp.Message) (Sender_send_Results, error) {
	root, err := msg.Root()
	return Sender_send_Results(root.Struct()), err
}

func (s Sender_send_Results) String() string {
	str, _ := text.Marshal(0xbb3101eccc20b4eb, capnp.Struct(s))
	return str
}

func (s Sender_send_Results) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Sender_send_Results) DecodeFromPtr(p capnp.Ptr) Sender_send_Results {
	return Sender_send_Results(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Sender_send_Results) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Sender_send_Results) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Sender_send_Results) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Sender_send_Results) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}

// Sender_send_Results_List is a list of Sender_send_Results.
type Sender_send_Results_List = capnp.StructList[Sender_send_Results]

// NewSender_send_Results creates a new list of Sender_send_Results.
func NewSender_send_Results_List(s *capnp.Segment, sz int32) (Sender_send_Results_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0}, sz)
	return capnp.StructList[Sender_send_Results](l), err
}

// Sender_send_Results_Future is a wrapper for a Sender_send_Results promised by a client call.
type Sender_send_Results_Future struct{ *capnp.Future }

func (f Sender_send_Results_Future) Struct() (Sender_send_Results, error) {
	p, err := f.Future.Ptr()
	return Sender_send_Results(p.Struct()), err
}

type Recver capnp.Client

// Recver_TypeID is the unique identifier for the type Recver.
const Recver_TypeID = 0xdf05a90d671c0c07

func (c Recver) Recv(ctx context.Context, params func(Recver_recv_Params) error) (Recver_recv_Results_Future, capnp.ReleaseFunc) {

	s := capnp.Send{
		Method: capnp.Method{
			InterfaceID:   0xdf05a90d671c0c07,
			MethodID:      0,
			InterfaceName: "channel.capnp:Recver",
			MethodName:    "recv",
		},
	}
	if params != nil {
		s.ArgsSize = capnp.ObjectSize{DataSize: 0, PointerCount: 0}
		s.PlaceArgs = func(s capnp.Struct) error { return params(Recver_recv_Params(s)) }
	}

	ans, release := capnp.Client(c).SendCall(ctx, s)
	return Recver_recv_Results_Future{Future: ans.Future()}, release

}

func (c Recver) WaitStreaming() error {
	return capnp.Client(c).WaitStreaming()
}

// String returns a string that identifies this capability for debugging
// purposes.  Its format should not be depended on: in particular, it
// should not be used to compare clients.  Use IsSame to compare clients
// for equality.
func (c Recver) String() string {
	return "Recver(" + capnp.Client(c).String() + ")"
}

// AddRef creates a new Client that refers to the same capability as c.
// If c is nil or has resolved to null, then AddRef returns nil.
func (c Recver) AddRef() Recver {
	return Recver(capnp.Client(c).AddRef())
}

// Release releases a capability reference.  If this is the last
// reference to the capability, then the underlying resources associated
// with the capability will be released.
//
// Release will panic if c has already been released, but not if c is
// nil or resolved to null.
func (c Recver) Release() {
	capnp.Client(c).Release()
}

// Resolve blocks until the capability is fully resolved or the Context
// expires.
func (c Recver) Resolve(ctx context.Context) error {
	return capnp.Client(c).Resolve(ctx)
}

func (c Recver) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Client(c).EncodeAsPtr(seg)
}

func (Recver) DecodeFromPtr(p capnp.Ptr) Recver {
	return Recver(capnp.Client{}.DecodeFromPtr(p))
}

// IsValid reports whether c is a valid reference to a capability.
// A reference is invalid if it is nil, has resolved to null, or has
// been released.
func (c Recver) IsValid() bool {
	return capnp.Client(c).IsValid()
}

// IsSame reports whether c and other refer to a capability created by the
// same call to NewClient.  This can return false negatives if c or other
// are not fully resolved: use Resolve if this is an issue.  If either
// c or other are released, then IsSame panics.
func (c Recver) IsSame(other Recver) bool {
	return capnp.Client(c).IsSame(capnp.Client(other))
}

// Update the flowcontrol.FlowLimiter used to manage flow control for
// this client. This affects all future calls, but not calls already
// waiting to send. Passing nil sets the value to flowcontrol.NopLimiter,
// which is also the default.
func (c Recver) SetFlowLimiter(lim fc.FlowLimiter) {
	capnp.Client(c).SetFlowLimiter(lim)
}

// Get the current flowcontrol.FlowLimiter used to manage flow control
// for this client.
func (c Recver) GetFlowLimiter() fc.FlowLimiter {
	return capnp.Client(c).GetFlowLimiter()
}

// A Recver_Server is a Recver with a local implementation.
type Recver_Server interface {
	Recv(context.Context, Recver_recv) error
}

// Recver_NewServer creates a new Server from an implementation of Recver_Server.
func Recver_NewServer(s Recver_Server) *server.Server {
	c, _ := s.(server.Shutdowner)
	return server.New(Recver_Methods(nil, s), s, c)
}

// Recver_ServerToClient creates a new Client from an implementation of Recver_Server.
// The caller is responsible for calling Release on the returned Client.
func Recver_ServerToClient(s Recver_Server) Recver {
	return Recver(capnp.NewClient(Recver_NewServer(s)))
}

// Recver_Methods appends Methods to a slice that invoke the methods on s.
// This can be used to create a more complicated Server.
func Recver_Methods(methods []server.Method, s Recver_Server) []server.Method {
	if cap(methods) == 0 {
		methods = make([]server.Method, 0, 1)
	}

	methods = append(methods, server.Method{
		Method: capnp.Method{
			InterfaceID:   0xdf05a90d671c0c07,
			MethodID:      0,
			InterfaceName: "channel.capnp:Recver",
			MethodName:    "recv",
		},
		Impl: func(ctx context.Context, call *server.Call) error {
			return s.Recv(ctx, Recver_recv{call})
		},
	})

	return methods
}

// Recver_recv holds the state for a server call to Recver.recv.
// See server.Call for documentation.
type Recver_recv struct {
	*server.Call
}

// Args returns the call's arguments.
func (c Recver_recv) Args() Recver_recv_Params {
	return Recver_recv_Params(c.Call.Args())
}

// AllocResults allocates the results struct.
func (c Recver_recv) AllocResults() (Recver_recv_Results, error) {
	r, err := c.Call.AllocResults(capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Recver_recv_Results(r), err
}

// Recver_List is a list of Recver.
type Recver_List = capnp.CapList[Recver]

// NewRecver creates a new list of Recver.
func NewRecver_List(s *capnp.Segment, sz int32) (Recver_List, error) {
	l, err := capnp.NewPointerList(s, sz)
	return capnp.CapList[Recver](l), err
}

type Recver_recv_Params capnp.Struct

// Recver_recv_Params_TypeID is the unique identifier for the type Recver_recv_Params.
const Recver_recv_Params_TypeID = 0xdd377ddc0d2426ea

func NewRecver_recv_Params(s *capnp.Segment) (Recver_recv_Params, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return Recver_recv_Params(st), err
}

func NewRootRecver_recv_Params(s *capnp.Segment) (Recver_recv_Params, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return Recver_recv_Params(st), err
}

func ReadRootRecver_recv_Params(msg *capnp.Message) (Recver_recv_Params, error) {
	root, err := msg.Root()
	return Recver_recv_Params(root.Struct()), err
}

func (s Recver_recv_Params) String() string {
	str, _ := text.Marshal(0xdd377ddc0d2426ea, capnp.Struct(s))
	return str
}

func (s Recver_recv_Params) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Recver_recv_Params) DecodeFromPtr(p capnp.Ptr) Recver_recv_Params {
	return Recver_recv_Params(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Recver_recv_Params) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Recver_recv_Params) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Recver_recv_Params) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Recver_recv_Params) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}

// Recver_recv_Params_List is a list of Recver_recv_Params.
type Recver_recv_Params_List = capnp.StructList[Recver_recv_Params]

// NewRecver_recv_Params creates a new list of Recver_recv_Params.
func NewRecver_recv_Params_List(s *capnp.Segment, sz int32) (Recver_recv_Params_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0}, sz)
	return capnp.StructList[Recver_recv_Params](l), err
}

// Recver_recv_Params_Future is a wrapper for a Recver_recv_Params promised by a client call.
type Recver_recv_Params_Future struct{ *capnp.Future }

func (f Recver_recv_Params_Future) Struct() (Recver_recv_Params, error) {
	p, err := f.Future.Ptr()
	return Recver_recv_Params(p.Struct()), err
}

type Recver_recv_Results capnp.Struct

// Recver_recv_Results_TypeID is the unique identifier for the type Recver_recv_Results.
const Recver_recv_Results_TypeID = 0xb0e88f4d0a3a1694

func NewRecver_recv_Results(s *capnp.Segment) (Recver_recv_Results, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Recver_recv_Results(st), err
}

func NewRootRecver_recv_Results(s *capnp.Segment) (Recver_recv_Results, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Recver_recv_Results(st), err
}

func ReadRootRecver_recv_Results(msg *capnp.Message) (Recver_recv_Results, error) {
	root, err := msg.Root()
	return Recver_recv_Results(root.Struct()), err
}

func (s Recver_recv_Results) String() string {
	str, _ := text.Marshal(0xb0e88f4d0a3a1694, capnp.Struct(s))
	return str
}

func (s Recver_recv_Results) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Recver_recv_Results) DecodeFromPtr(p capnp.Ptr) Recver_recv_Results {
	return Recver_recv_Results(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Recver_recv_Results) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Recver_recv_Results) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Recver_recv_Results) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Recver_recv_Results) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Recver_recv_Results) Value() (capnp.Ptr, error) {
	return capnp.Struct(s).Ptr(0)
}

func (s Recver_recv_Results) HasValue() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s Recver_recv_Results) SetValue(v capnp.Ptr) error {
	return capnp.Struct(s).SetPtr(0, v)
}

// Recver_recv_Results_List is a list of Recver_recv_Results.
type Recver_recv_Results_List = capnp.StructList[Recver_recv_Results]

// NewRecver_recv_Results creates a new list of Recver_recv_Results.
func NewRecver_recv_Results_List(s *capnp.Segment, sz int32) (Recver_recv_Results_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return capnp.StructList[Recver_recv_Results](l), err
}

// Recver_recv_Results_Future is a wrapper for a Recver_recv_Results promised by a client call.
type Recver_recv_Results_Future struct{ *capnp.Future }

func (f Recver_recv_Results_Future) Struct() (Recver_recv_Results, error) {
	p, err := f.Future.Ptr()
	return Recver_recv_Results(p.Struct()), err
}
func (p Recver_recv_Results_Future) Value() *capnp.Future {
	return p.Future.Field(0, nil)
}

type SendCloser capnp.Client

// SendCloser_TypeID is the unique identifier for the type SendCloser.
const SendCloser_TypeID = 0xe9a7d19a7d14e94e

func (c SendCloser) NewSender(ctx context.Context, params func(SendCloser_newSender_Params) error) (SendCloser_newSender_Results_Future, capnp.ReleaseFunc) {

	s := capnp.Send{
		Method: capnp.Method{
			InterfaceID:   0xe9a7d19a7d14e94e,
			MethodID:      0,
			InterfaceName: "channel.capnp:SendCloser",
			MethodName:    "newSender",
		},
	}
	if params != nil {
		s.ArgsSize = capnp.ObjectSize{DataSize: 0, PointerCount: 0}
		s.PlaceArgs = func(s capnp.Struct) error { return params(SendCloser_newSender_Params(s)) }
	}

	ans, release := capnp.Client(c).SendCall(ctx, s)
	return SendCloser_newSender_Results_Future{Future: ans.Future()}, release

}

func (c SendCloser) NewCloser(ctx context.Context, params func(SendCloser_newCloser_Params) error) (SendCloser_newCloser_Results_Future, capnp.ReleaseFunc) {

	s := capnp.Send{
		Method: capnp.Method{
			InterfaceID:   0xe9a7d19a7d14e94e,
			MethodID:      1,
			InterfaceName: "channel.capnp:SendCloser",
			MethodName:    "newCloser",
		},
	}
	if params != nil {
		s.ArgsSize = capnp.ObjectSize{DataSize: 0, PointerCount: 0}
		s.PlaceArgs = func(s capnp.Struct) error { return params(SendCloser_newCloser_Params(s)) }
	}

	ans, release := capnp.Client(c).SendCall(ctx, s)
	return SendCloser_newCloser_Results_Future{Future: ans.Future()}, release

}

func (c SendCloser) Send(ctx context.Context, params func(Sender_send_Params) error) (Sender_send_Results_Future, capnp.ReleaseFunc) {

	s := capnp.Send{
		Method: capnp.Method{
			InterfaceID:   0xe8bbed1438ea16ee,
			MethodID:      0,
			InterfaceName: "channel.capnp:Sender",
			MethodName:    "send",
		},
	}
	if params != nil {
		s.ArgsSize = capnp.ObjectSize{DataSize: 0, PointerCount: 1}
		s.PlaceArgs = func(s capnp.Struct) error { return params(Sender_send_Params(s)) }
	}

	ans, release := capnp.Client(c).SendCall(ctx, s)
	return Sender_send_Results_Future{Future: ans.Future()}, release

}

func (c SendCloser) Close(ctx context.Context, params func(Closer_close_Params) error) (Closer_close_Results_Future, capnp.ReleaseFunc) {

	s := capnp.Send{
		Method: capnp.Method{
			InterfaceID:   0xfad0e4b80d3779c3,
			MethodID:      0,
			InterfaceName: "channel.capnp:Closer",
			MethodName:    "close",
		},
	}
	if params != nil {
		s.ArgsSize = capnp.ObjectSize{DataSize: 0, PointerCount: 0}
		s.PlaceArgs = func(s capnp.Struct) error { return params(Closer_close_Params(s)) }
	}

	ans, release := capnp.Client(c).SendCall(ctx, s)
	return Closer_close_Results_Future{Future: ans.Future()}, release

}

func (c SendCloser) WaitStreaming() error {
	return capnp.Client(c).WaitStreaming()
}

// String returns a string that identifies this capability for debugging
// purposes.  Its format should not be depended on: in particular, it
// should not be used to compare clients.  Use IsSame to compare clients
// for equality.
func (c SendCloser) String() string {
	return "SendCloser(" + capnp.Client(c).String() + ")"
}

// AddRef creates a new Client that refers to the same capability as c.
// If c is nil or has resolved to null, then AddRef returns nil.
func (c SendCloser) AddRef() SendCloser {
	return SendCloser(capnp.Client(c).AddRef())
}

// Release releases a capability reference.  If this is the last
// reference to the capability, then the underlying resources associated
// with the capability will be released.
//
// Release will panic if c has already been released, but not if c is
// nil or resolved to null.
func (c SendCloser) Release() {
	capnp.Client(c).Release()
}

// Resolve blocks until the capability is fully resolved or the Context
// expires.
func (c SendCloser) Resolve(ctx context.Context) error {
	return capnp.Client(c).Resolve(ctx)
}

func (c SendCloser) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Client(c).EncodeAsPtr(seg)
}

func (SendCloser) DecodeFromPtr(p capnp.Ptr) SendCloser {
	return SendCloser(capnp.Client{}.DecodeFromPtr(p))
}

// IsValid reports whether c is a valid reference to a capability.
// A reference is invalid if it is nil, has resolved to null, or has
// been released.
func (c SendCloser) IsValid() bool {
	return capnp.Client(c).IsValid()
}

// IsSame reports whether c and other refer to a capability created by the
// same call to NewClient.  This can return false negatives if c or other
// are not fully resolved: use Resolve if this is an issue.  If either
// c or other are released, then IsSame panics.
func (c SendCloser) IsSame(other SendCloser) bool {
	return capnp.Client(c).IsSame(capnp.Client(other))
}

// Update the flowcontrol.FlowLimiter used to manage flow control for
// this client. This affects all future calls, but not calls already
// waiting to send. Passing nil sets the value to flowcontrol.NopLimiter,
// which is also the default.
func (c SendCloser) SetFlowLimiter(lim fc.FlowLimiter) {
	capnp.Client(c).SetFlowLimiter(lim)
}

// Get the current flowcontrol.FlowLimiter used to manage flow control
// for this client.
func (c SendCloser) GetFlowLimiter() fc.FlowLimiter {
	return capnp.Client(c).GetFlowLimiter()
}

// A SendCloser_Server is a SendCloser with a local implementation.
type SendCloser_Server interface {
	NewSender(context.Context, SendCloser_newSender) error

	NewCloser(context.Context, SendCloser_newCloser) error

	Send(context.Context, Sender_send) error

	Close(context.Context, Closer_close) error
}

// SendCloser_NewServer creates a new Server from an implementation of SendCloser_Server.
func SendCloser_NewServer(s SendCloser_Server) *server.Server {
	c, _ := s.(server.Shutdowner)
	return server.New(SendCloser_Methods(nil, s), s, c)
}

// SendCloser_ServerToClient creates a new Client from an implementation of SendCloser_Server.
// The caller is responsible for calling Release on the returned Client.
func SendCloser_ServerToClient(s SendCloser_Server) SendCloser {
	return SendCloser(capnp.NewClient(SendCloser_NewServer(s)))
}

// SendCloser_Methods appends Methods to a slice that invoke the methods on s.
// This can be used to create a more complicated Server.
func SendCloser_Methods(methods []server.Method, s SendCloser_Server) []server.Method {
	if cap(methods) == 0 {
		methods = make([]server.Method, 0, 4)
	}

	methods = append(methods, server.Method{
		Method: capnp.Method{
			InterfaceID:   0xe9a7d19a7d14e94e,
			MethodID:      0,
			InterfaceName: "channel.capnp:SendCloser",
			MethodName:    "newSender",
		},
		Impl: func(ctx context.Context, call *server.Call) error {
			return s.NewSender(ctx, SendCloser_newSender{call})
		},
	})

	methods = append(methods, server.Method{
		Method: capnp.Method{
			InterfaceID:   0xe9a7d19a7d14e94e,
			MethodID:      1,
			InterfaceName: "channel.capnp:SendCloser",
			MethodName:    "newCloser",
		},
		Impl: func(ctx context.Context, call *server.Call) error {
			return s.NewCloser(ctx, SendCloser_newCloser{call})
		},
	})

	methods = append(methods, server.Method{
		Method: capnp.Method{
			InterfaceID:   0xe8bbed1438ea16ee,
			MethodID:      0,
			InterfaceName: "channel.capnp:Sender",
			MethodName:    "send",
		},
		Impl: func(ctx context.Context, call *server.Call) error {
			return s.Send(ctx, Sender_send{call})
		},
	})

	methods = append(methods, server.Method{
		Method: capnp.Method{
			InterfaceID:   0xfad0e4b80d3779c3,
			MethodID:      0,
			InterfaceName: "channel.capnp:Closer",
			MethodName:    "close",
		},
		Impl: func(ctx context.Context, call *server.Call) error {
			return s.Close(ctx, Closer_close{call})
		},
	})

	return methods
}

// SendCloser_newSender holds the state for a server call to SendCloser.newSender.
// See server.Call for documentation.
type SendCloser_newSender struct {
	*server.Call
}

// Args returns the call's arguments.
func (c SendCloser_newSender) Args() SendCloser_newSender_Params {
	return SendCloser_newSender_Params(c.Call.Args())
}

// AllocResults allocates the results struct.
func (c SendCloser_newSender) AllocResults() (SendCloser_newSender_Results, error) {
	r, err := c.Call.AllocResults(capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return SendCloser_newSender_Results(r), err
}

// SendCloser_newCloser holds the state for a server call to SendCloser.newCloser.
// See server.Call for documentation.
type SendCloser_newCloser struct {
	*server.Call
}

// Args returns the call's arguments.
func (c SendCloser_newCloser) Args() SendCloser_newCloser_Params {
	return SendCloser_newCloser_Params(c.Call.Args())
}

// AllocResults allocates the results struct.
func (c SendCloser_newCloser) AllocResults() (SendCloser_newCloser_Results, error) {
	r, err := c.Call.AllocResults(capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return SendCloser_newCloser_Results(r), err
}

// SendCloser_List is a list of SendCloser.
type SendCloser_List = capnp.CapList[SendCloser]

// NewSendCloser creates a new list of SendCloser.
func NewSendCloser_List(s *capnp.Segment, sz int32) (SendCloser_List, error) {
	l, err := capnp.NewPointerList(s, sz)
	return capnp.CapList[SendCloser](l), err
}

type SendCloser_newSender_Params capnp.Struct

// SendCloser_newSender_Params_TypeID is the unique identifier for the type SendCloser_newSender_Params.
const SendCloser_newSender_Params_TypeID = 0xbb370dcc71a43ba9

func NewSendCloser_newSender_Params(s *capnp.Segment) (SendCloser_newSender_Params, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return SendCloser_newSender_Params(st), err
}

func NewRootSendCloser_newSender_Params(s *capnp.Segment) (SendCloser_newSender_Params, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return SendCloser_newSender_Params(st), err
}

func ReadRootSendCloser_newSender_Params(msg *capnp.Message) (SendCloser_newSender_Params, error) {
	root, err := msg.Root()
	return SendCloser_newSender_Params(root.Struct()), err
}

func (s SendCloser_newSender_Params) String() string {
	str, _ := text.Marshal(0xbb370dcc71a43ba9, capnp.Struct(s))
	return str
}

func (s SendCloser_newSender_Params) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (SendCloser_newSender_Params) DecodeFromPtr(p capnp.Ptr) SendCloser_newSender_Params {
	return SendCloser_newSender_Params(capnp.Struct{}.DecodeFromPtr(p))
}

func (s SendCloser_newSender_Params) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s SendCloser_newSender_Params) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s SendCloser_newSender_Params) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s SendCloser_newSender_Params) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}

// SendCloser_newSender_Params_List is a list of SendCloser_newSender_Params.
type SendCloser_newSender_Params_List = capnp.StructList[SendCloser_newSender_Params]

// NewSendCloser_newSender_Params creates a new list of SendCloser_newSender_Params.
func NewSendCloser_newSender_Params_List(s *capnp.Segment, sz int32) (SendCloser_newSender_Params_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0}, sz)
	return capnp.StructList[SendCloser_newSender_Params](l), err
}

// SendCloser_newSender_Params_Future is a wrapper for a SendCloser_newSender_Params promised by a client call.
type SendCloser_newSender_Params_Future struct{ *capnp.Future }

func (f SendCloser_newSender_Params_Future) Struct() (SendCloser_newSender_Params, error) {
	p, err := f.Future.Ptr()
	return SendCloser_newSender_Params(p.Struct()), err
}

type SendCloser_newSender_Results capnp.Struct

// SendCloser_newSender_Results_TypeID is the unique identifier for the type SendCloser_newSender_Results.
const SendCloser_newSender_Results_TypeID = 0xca7110014301ab81

func NewSendCloser_newSender_Results(s *capnp.Segment) (SendCloser_newSender_Results, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return SendCloser_newSender_Results(st), err
}

func NewRootSendCloser_newSender_Results(s *capnp.Segment) (SendCloser_newSender_Results, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return SendCloser_newSender_Results(st), err
}

func ReadRootSendCloser_newSender_Results(msg *capnp.Message) (SendCloser_newSender_Results, error) {
	root, err := msg.Root()
	return SendCloser_newSender_Results(root.Struct()), err
}

func (s SendCloser_newSender_Results) String() string {
	str, _ := text.Marshal(0xca7110014301ab81, capnp.Struct(s))
	return str
}

func (s SendCloser_newSender_Results) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (SendCloser_newSender_Results) DecodeFromPtr(p capnp.Ptr) SendCloser_newSender_Results {
	return SendCloser_newSender_Results(capnp.Struct{}.DecodeFromPtr(p))
}

func (s SendCloser_newSender_Results) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s SendCloser_newSender_Results) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s SendCloser_newSender_Results) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s SendCloser_newSender_Results) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s SendCloser_newSender_Results) Sender() Sender {
	p, _ := capnp.Struct(s).Ptr(0)
	return Sender(p.Interface().Client())
}

func (s SendCloser_newSender_Results) HasSender() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s SendCloser_newSender_Results) SetSender(v Sender) error {
	if !v.IsValid() {
		return capnp.Struct(s).SetPtr(0, capnp.Ptr{})
	}
	seg := s.Segment()
	in := capnp.NewInterface(seg, seg.Message().CapTable().Add(capnp.Client(v)))
	return capnp.Struct(s).SetPtr(0, in.ToPtr())
}

// SendCloser_newSender_Results_List is a list of SendCloser_newSender_Results.
type SendCloser_newSender_Results_List = capnp.StructList[SendCloser_newSender_Results]

// NewSendCloser_newSender_Results creates a new list of SendCloser_newSender_Results.
func NewSendCloser_newSender_Results_List(s *capnp.Segment, sz int32) (SendCloser_newSender_Results_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return capnp.StructList[SendCloser_newSender_Results](l), err
}

// SendCloser_newSender_Results_Future is a wrapper for a SendCloser_newSender_Results promised by a client call.
type SendCloser_newSender_Results_Future struct{ *capnp.Future }

func (f SendCloser_newSender_Results_Future) Struct() (SendCloser_newSender_Results, error) {
	p, err := f.Future.Ptr()
	return SendCloser_newSender_Results(p.Struct()), err
}
func (p SendCloser_newSender_Results_Future) Sender() Sender {
	return Sender(p.Future.Field(0, nil).Client())
}

type SendCloser_newCloser_Params capnp.Struct

// SendCloser_newCloser_Params_TypeID is the unique identifier for the type SendCloser_newCloser_Params.
const SendCloser_newCloser_Params_TypeID = 0xe48d9443d96ba68d

func NewSendCloser_newCloser_Params(s *capnp.Segment) (SendCloser_newCloser_Params, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return SendCloser_newCloser_Params(st), err
}

func NewRootSendCloser_newCloser_Params(s *capnp.Segment) (SendCloser_newCloser_Params, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return SendCloser_newCloser_Params(st), err
}

func ReadRootSendCloser_newCloser_Params(msg *capnp.Message) (SendCloser_newCloser_Params, error) {
	root, err := msg.Root()
	return SendCloser_newCloser_Params(root.Struct()), err
}

func (s SendCloser_newCloser_Params) String() string {
	str, _ := text.Marshal(0xe48d9443d96ba68d, capnp.Struct(s))
	return str
}

func (s SendCloser_newCloser_Params) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (SendCloser_newCloser_Params) DecodeFromPtr(p capnp.Ptr) SendCloser_newCloser_Params {
	return SendCloser_newCloser_Params(capnp.Struct{}.DecodeFromPtr(p))
}

func (s SendCloser_newCloser_Params) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s SendCloser_newCloser_Params) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s SendCloser_newCloser_Params) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s SendCloser_newCloser_Params) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}

// SendCloser_newCloser_Params_List is a list of SendCloser_newCloser_Params.
type SendCloser_newCloser_Params_List = capnp.StructList[SendCloser_newCloser_Params]

// NewSendCloser_newCloser_Params creates a new list of SendCloser_newCloser_Params.
func NewSendCloser_newCloser_Params_List(s *capnp.Segment, sz int32) (SendCloser_newCloser_Params_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0}, sz)
	return capnp.StructList[SendCloser_newCloser_Params](l), err
}

// SendCloser_newCloser_Params_Future is a wrapper for a SendCloser_newCloser_Params promised by a client call.
type SendCloser_newCloser_Params_Future struct{ *capnp.Future }

func (f SendCloser_newCloser_Params_Future) Struct() (SendCloser_newCloser_Params, error) {
	p, err := f.Future.Ptr()
	return SendCloser_newCloser_Params(p.Struct()), err
}

type SendCloser_newCloser_Results capnp.Struct

// SendCloser_newCloser_Results_TypeID is the unique identifier for the type SendCloser_newCloser_Results.
const SendCloser_newCloser_Results_TypeID = 0xf1dd4079b7c319f1

func NewSendCloser_newCloser_Results(s *capnp.Segment) (SendCloser_newCloser_Results, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return SendCloser_newCloser_Results(st), err
}

func NewRootSendCloser_newCloser_Results(s *capnp.Segment) (SendCloser_newCloser_Results, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return SendCloser_newCloser_Results(st), err
}

func ReadRootSendCloser_newCloser_Results(msg *capnp.Message) (SendCloser_newCloser_Results, error) {
	root, err := msg.Root()
	return SendCloser_newCloser_Results(root.Struct()), err
}

func (s SendCloser_newCloser_Results) String() string {
	str, _ := text.Marshal(0xf1dd4079b7c319f1, capnp.Struct(s))
	return str
}

func (s SendCloser_newCloser_Results) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (SendCloser_newCloser_Results) DecodeFromPtr(p capnp.Ptr) SendCloser_newCloser_Results {
	return SendCloser_newCloser_Results(capnp.Struct{}.DecodeFromPtr(p))
}

func (s SendCloser_newCloser_Results) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s SendCloser_newCloser_Results) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s SendCloser_newCloser_Results) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s SendCloser_newCloser_Results) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s SendCloser_newCloser_Results) Closer() Closer {
	p, _ := capnp.Struct(s).Ptr(0)
	return Closer(p.Interface().Client())
}

func (s SendCloser_newCloser_Results) HasCloser() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s SendCloser_newCloser_Results) SetCloser(v Closer) error {
	if !v.IsValid() {
		return capnp.Struct(s).SetPtr(0, capnp.Ptr{})
	}
	seg := s.Segment()
	in := capnp.NewInterface(seg, seg.Message().CapTable().Add(capnp.Client(v)))
	return capnp.Struct(s).SetPtr(0, in.ToPtr())
}

// SendCloser_newCloser_Results_List is a list of SendCloser_newCloser_Results.
type SendCloser_newCloser_Results_List = capnp.StructList[SendCloser_newCloser_Results]

// NewSendCloser_newCloser_Results creates a new list of SendCloser_newCloser_Results.
func NewSendCloser_newCloser_Results_List(s *capnp.Segment, sz int32) (SendCloser_newCloser_Results_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return capnp.StructList[SendCloser_newCloser_Results](l), err
}

// SendCloser_newCloser_Results_Future is a wrapper for a SendCloser_newCloser_Results promised by a client call.
type SendCloser_newCloser_Results_Future struct{ *capnp.Future }

func (f SendCloser_newCloser_Results_Future) Struct() (SendCloser_newCloser_Results, error) {
	p, err := f.Future.Ptr()
	return SendCloser_newCloser_Results(p.Struct()), err
}
func (p SendCloser_newCloser_Results_Future) Closer() Closer {
	return Closer(p.Future.Field(0, nil).Client())
}

type Chan capnp.Client

// Chan_TypeID is the unique identifier for the type Chan.
const Chan_TypeID = 0x95c89fe7d966f751

func (c Chan) NewSendCloser(ctx context.Context, params func(Chan_newSendCloser_Params) error) (Chan_newSendCloser_Results_Future, capnp.ReleaseFunc) {

	s := capnp.Send{
		Method: capnp.Method{
			InterfaceID:   0x95c89fe7d966f751,
			MethodID:      0,
			InterfaceName: "channel.capnp:Chan",
			MethodName:    "newSendCloser",
		},
	}
	if params != nil {
		s.ArgsSize = capnp.ObjectSize{DataSize: 0, PointerCount: 0}
		s.PlaceArgs = func(s capnp.Struct) error { return params(Chan_newSendCloser_Params(s)) }
	}

	ans, release := capnp.Client(c).SendCall(ctx, s)
	return Chan_newSendCloser_Results_Future{Future: ans.Future()}, release

}

func (c Chan) NewRecver(ctx context.Context, params func(Chan_newRecver_Params) error) (Chan_newRecver_Results_Future, capnp.ReleaseFunc) {

	s := capnp.Send{
		Method: capnp.Method{
			InterfaceID:   0x95c89fe7d966f751,
			MethodID:      1,
			InterfaceName: "channel.capnp:Chan",
			MethodName:    "newRecver",
		},
	}
	if params != nil {
		s.ArgsSize = capnp.ObjectSize{DataSize: 0, PointerCount: 0}
		s.PlaceArgs = func(s capnp.Struct) error { return params(Chan_newRecver_Params(s)) }
	}

	ans, release := capnp.Client(c).SendCall(ctx, s)
	return Chan_newRecver_Results_Future{Future: ans.Future()}, release

}

func (c Chan) NewSender(ctx context.Context, params func(SendCloser_newSender_Params) error) (SendCloser_newSender_Results_Future, capnp.ReleaseFunc) {

	s := capnp.Send{
		Method: capnp.Method{
			InterfaceID:   0xe9a7d19a7d14e94e,
			MethodID:      0,
			InterfaceName: "channel.capnp:SendCloser",
			MethodName:    "newSender",
		},
	}
	if params != nil {
		s.ArgsSize = capnp.ObjectSize{DataSize: 0, PointerCount: 0}
		s.PlaceArgs = func(s capnp.Struct) error { return params(SendCloser_newSender_Params(s)) }
	}

	ans, release := capnp.Client(c).SendCall(ctx, s)
	return SendCloser_newSender_Results_Future{Future: ans.Future()}, release

}

func (c Chan) NewCloser(ctx context.Context, params func(SendCloser_newCloser_Params) error) (SendCloser_newCloser_Results_Future, capnp.ReleaseFunc) {

	s := capnp.Send{
		Method: capnp.Method{
			InterfaceID:   0xe9a7d19a7d14e94e,
			MethodID:      1,
			InterfaceName: "channel.capnp:SendCloser",
			MethodName:    "newCloser",
		},
	}
	if params != nil {
		s.ArgsSize = capnp.ObjectSize{DataSize: 0, PointerCount: 0}
		s.PlaceArgs = func(s capnp.Struct) error { return params(SendCloser_newCloser_Params(s)) }
	}

	ans, release := capnp.Client(c).SendCall(ctx, s)
	return SendCloser_newCloser_Results_Future{Future: ans.Future()}, release

}

func (c Chan) Send(ctx context.Context, params func(Sender_send_Params) error) (Sender_send_Results_Future, capnp.ReleaseFunc) {

	s := capnp.Send{
		Method: capnp.Method{
			InterfaceID:   0xe8bbed1438ea16ee,
			MethodID:      0,
			InterfaceName: "channel.capnp:Sender",
			MethodName:    "send",
		},
	}
	if params != nil {
		s.ArgsSize = capnp.ObjectSize{DataSize: 0, PointerCount: 1}
		s.PlaceArgs = func(s capnp.Struct) error { return params(Sender_send_Params(s)) }
	}

	ans, release := capnp.Client(c).SendCall(ctx, s)
	return Sender_send_Results_Future{Future: ans.Future()}, release

}

func (c Chan) Close(ctx context.Context, params func(Closer_close_Params) error) (Closer_close_Results_Future, capnp.ReleaseFunc) {

	s := capnp.Send{
		Method: capnp.Method{
			InterfaceID:   0xfad0e4b80d3779c3,
			MethodID:      0,
			InterfaceName: "channel.capnp:Closer",
			MethodName:    "close",
		},
	}
	if params != nil {
		s.ArgsSize = capnp.ObjectSize{DataSize: 0, PointerCount: 0}
		s.PlaceArgs = func(s capnp.Struct) error { return params(Closer_close_Params(s)) }
	}

	ans, release := capnp.Client(c).SendCall(ctx, s)
	return Closer_close_Results_Future{Future: ans.Future()}, release

}

func (c Chan) Recv(ctx context.Context, params func(Recver_recv_Params) error) (Recver_recv_Results_Future, capnp.ReleaseFunc) {

	s := capnp.Send{
		Method: capnp.Method{
			InterfaceID:   0xdf05a90d671c0c07,
			MethodID:      0,
			InterfaceName: "channel.capnp:Recver",
			MethodName:    "recv",
		},
	}
	if params != nil {
		s.ArgsSize = capnp.ObjectSize{DataSize: 0, PointerCount: 0}
		s.PlaceArgs = func(s capnp.Struct) error { return params(Recver_recv_Params(s)) }
	}

	ans, release := capnp.Client(c).SendCall(ctx, s)
	return Recver_recv_Results_Future{Future: ans.Future()}, release

}

func (c Chan) WaitStreaming() error {
	return capnp.Client(c).WaitStreaming()
}

// String returns a string that identifies this capability for debugging
// purposes.  Its format should not be depended on: in particular, it
// should not be used to compare clients.  Use IsSame to compare clients
// for equality.
func (c Chan) String() string {
	return "Chan(" + capnp.Client(c).String() + ")"
}

// AddRef creates a new Client that refers to the same capability as c.
// If c is nil or has resolved to null, then AddRef returns nil.
func (c Chan) AddRef() Chan {
	return Chan(capnp.Client(c).AddRef())
}

// Release releases a capability reference.  If this is the last
// reference to the capability, then the underlying resources associated
// with the capability will be released.
//
// Release will panic if c has already been released, but not if c is
// nil or resolved to null.
func (c Chan) Release() {
	capnp.Client(c).Release()
}

// Resolve blocks until the capability is fully resolved or the Context
// expires.
func (c Chan) Resolve(ctx context.Context) error {
	return capnp.Client(c).Resolve(ctx)
}

func (c Chan) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Client(c).EncodeAsPtr(seg)
}

func (Chan) DecodeFromPtr(p capnp.Ptr) Chan {
	return Chan(capnp.Client{}.DecodeFromPtr(p))
}

// IsValid reports whether c is a valid reference to a capability.
// A reference is invalid if it is nil, has resolved to null, or has
// been released.
func (c Chan) IsValid() bool {
	return capnp.Client(c).IsValid()
}

// IsSame reports whether c and other refer to a capability created by the
// same call to NewClient.  This can return false negatives if c or other
// are not fully resolved: use Resolve if this is an issue.  If either
// c or other are released, then IsSame panics.
func (c Chan) IsSame(other Chan) bool {
	return capnp.Client(c).IsSame(capnp.Client(other))
}

// Update the flowcontrol.FlowLimiter used to manage flow control for
// this client. This affects all future calls, but not calls already
// waiting to send. Passing nil sets the value to flowcontrol.NopLimiter,
// which is also the default.
func (c Chan) SetFlowLimiter(lim fc.FlowLimiter) {
	capnp.Client(c).SetFlowLimiter(lim)
}

// Get the current flowcontrol.FlowLimiter used to manage flow control
// for this client.
func (c Chan) GetFlowLimiter() fc.FlowLimiter {
	return capnp.Client(c).GetFlowLimiter()
}

// A Chan_Server is a Chan with a local implementation.
type Chan_Server interface {
	NewSendCloser(context.Context, Chan_newSendCloser) error

	NewRecver(context.Context, Chan_newRecver) error

	NewSender(context.Context, SendCloser_newSender) error

	NewCloser(context.Context, SendCloser_newCloser) error

	Send(context.Context, Sender_send) error

	Close(context.Context, Closer_close) error

	Recv(context.Context, Recver_recv) error
}

// Chan_NewServer creates a new Server from an implementation of Chan_Server.
func Chan_NewServer(s Chan_Server) *server.Server {
	c, _ := s.(server.Shutdowner)
	return server.New(Chan_Methods(nil, s), s, c)
}

// Chan_ServerToClient creates a new Client from an implementation of Chan_Server.
// The caller is responsible for calling Release on the returned Client.
func Chan_ServerToClient(s Chan_Server) Chan {
	return Chan(capnp.NewClient(Chan_NewServer(s)))
}

// Chan_Methods appends Methods to a slice that invoke the methods on s.
// This can be used to create a more complicated Server.
func Chan_Methods(methods []server.Method, s Chan_Server) []server.Method {
	if cap(methods) == 0 {
		methods = make([]server.Method, 0, 7)
	}

	methods = append(methods, server.Method{
		Method: capnp.Method{
			InterfaceID:   0x95c89fe7d966f751,
			MethodID:      0,
			InterfaceName: "channel.capnp:Chan",
			MethodName:    "newSendCloser",
		},
		Impl: func(ctx context.Context, call *server.Call) error {
			return s.NewSendCloser(ctx, Chan_newSendCloser{call})
		},
	})

	methods = append(methods, server.Method{
		Method: capnp.Method{
			InterfaceID:   0x95c89fe7d966f751,
			MethodID:      1,
			InterfaceName: "channel.capnp:Chan",
			MethodName:    "newRecver",
		},
		Impl: func(ctx context.Context, call *server.Call) error {
			return s.NewRecver(ctx, Chan_newRecver{call})
		},
	})

	methods = append(methods, server.Method{
		Method: capnp.Method{
			InterfaceID:   0xe9a7d19a7d14e94e,
			MethodID:      0,
			InterfaceName: "channel.capnp:SendCloser",
			MethodName:    "newSender",
		},
		Impl: func(ctx context.Context, call *server.Call) error {
			return s.NewSender(ctx, SendCloser_newSender{call})
		},
	})

	methods = append(methods, server.Method{
		Method: capnp.Method{
			InterfaceID:   0xe9a7d19a7d14e94e,
			MethodID:      1,
			InterfaceName: "channel.capnp:SendCloser",
			MethodName:    "newCloser",
		},
		Impl: func(ctx context.Context, call *server.Call) error {
			return s.NewCloser(ctx, SendCloser_newCloser{call})
		},
	})

	methods = append(methods, server.Method{
		Method: capnp.Method{
			InterfaceID:   0xe8bbed1438ea16ee,
			MethodID:      0,
			InterfaceName: "channel.capnp:Sender",
			MethodName:    "send",
		},
		Impl: func(ctx context.Context, call *server.Call) error {
			return s.Send(ctx, Sender_send{call})
		},
	})

	methods = append(methods, server.Method{
		Method: capnp.Method{
			InterfaceID:   0xfad0e4b80d3779c3,
			MethodID:      0,
			InterfaceName: "channel.capnp:Closer",
			MethodName:    "close",
		},
		Impl: func(ctx context.Context, call *server.Call) error {
			return s.Close(ctx, Closer_close{call})
		},
	})

	methods = append(methods, server.Method{
		Method: capnp.Method{
			InterfaceID:   0xdf05a90d671c0c07,
			MethodID:      0,
			InterfaceName: "channel.capnp:Recver",
			MethodName:    "recv",
		},
		Impl: func(ctx context.Context, call *server.Call) error {
			return s.Recv(ctx, Recver_recv{call})
		},
	})

	return methods
}

// Chan_newSendCloser holds the state for a server call to Chan.newSendCloser.
// See server.Call for documentation.
type Chan_newSendCloser struct {
	*server.Call
}

// Args returns the call's arguments.
func (c Chan_newSendCloser) Args() Chan_newSendCloser_Params {
	return Chan_newSendCloser_Params(c.Call.Args())
}

// AllocResults allocates the results struct.
func (c Chan_newSendCloser) AllocResults() (Chan_newSendCloser_Results, error) {
	r, err := c.Call.AllocResults(capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Chan_newSendCloser_Results(r), err
}

// Chan_newRecver holds the state for a server call to Chan.newRecver.
// See server.Call for documentation.
type Chan_newRecver struct {
	*server.Call
}

// Args returns the call's arguments.
func (c Chan_newRecver) Args() Chan_newRecver_Params {
	return Chan_newRecver_Params(c.Call.Args())
}

// AllocResults allocates the results struct.
func (c Chan_newRecver) AllocResults() (Chan_newRecver_Results, error) {
	r, err := c.Call.AllocResults(capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Chan_newRecver_Results(r), err
}

// Chan_List is a list of Chan.
type Chan_List = capnp.CapList[Chan]

// NewChan creates a new list of Chan.
func NewChan_List(s *capnp.Segment, sz int32) (Chan_List, error) {
	l, err := capnp.NewPointerList(s, sz)
	return capnp.CapList[Chan](l), err
}

type Chan_newSendCloser_Params capnp.Struct

// Chan_newSendCloser_Params_TypeID is the unique identifier for the type Chan_newSendCloser_Params.
const Chan_newSendCloser_Params_TypeID = 0xe76adde17bd7c3df

func NewChan_newSendCloser_Params(s *capnp.Segment) (Chan_newSendCloser_Params, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return Chan_newSendCloser_Params(st), err
}

func NewRootChan_newSendCloser_Params(s *capnp.Segment) (Chan_newSendCloser_Params, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return Chan_newSendCloser_Params(st), err
}

func ReadRootChan_newSendCloser_Params(msg *capnp.Message) (Chan_newSendCloser_Params, error) {
	root, err := msg.Root()
	return Chan_newSendCloser_Params(root.Struct()), err
}

func (s Chan_newSendCloser_Params) String() string {
	str, _ := text.Marshal(0xe76adde17bd7c3df, capnp.Struct(s))
	return str
}

func (s Chan_newSendCloser_Params) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Chan_newSendCloser_Params) DecodeFromPtr(p capnp.Ptr) Chan_newSendCloser_Params {
	return Chan_newSendCloser_Params(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Chan_newSendCloser_Params) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Chan_newSendCloser_Params) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Chan_newSendCloser_Params) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Chan_newSendCloser_Params) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}

// Chan_newSendCloser_Params_List is a list of Chan_newSendCloser_Params.
type Chan_newSendCloser_Params_List = capnp.StructList[Chan_newSendCloser_Params]

// NewChan_newSendCloser_Params creates a new list of Chan_newSendCloser_Params.
func NewChan_newSendCloser_Params_List(s *capnp.Segment, sz int32) (Chan_newSendCloser_Params_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0}, sz)
	return capnp.StructList[Chan_newSendCloser_Params](l), err
}

// Chan_newSendCloser_Params_Future is a wrapper for a Chan_newSendCloser_Params promised by a client call.
type Chan_newSendCloser_Params_Future struct{ *capnp.Future }

func (f Chan_newSendCloser_Params_Future) Struct() (Chan_newSendCloser_Params, error) {
	p, err := f.Future.Ptr()
	return Chan_newSendCloser_Params(p.Struct()), err
}

type Chan_newSendCloser_Results capnp.Struct

// Chan_newSendCloser_Results_TypeID is the unique identifier for the type Chan_newSendCloser_Results.
const Chan_newSendCloser_Results_TypeID = 0xcbbc3fcd0d01a855

func NewChan_newSendCloser_Results(s *capnp.Segment) (Chan_newSendCloser_Results, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Chan_newSendCloser_Results(st), err
}

func NewRootChan_newSendCloser_Results(s *capnp.Segment) (Chan_newSendCloser_Results, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Chan_newSendCloser_Results(st), err
}

func ReadRootChan_newSendCloser_Results(msg *capnp.Message) (Chan_newSendCloser_Results, error) {
	root, err := msg.Root()
	return Chan_newSendCloser_Results(root.Struct()), err
}

func (s Chan_newSendCloser_Results) String() string {
	str, _ := text.Marshal(0xcbbc3fcd0d01a855, capnp.Struct(s))
	return str
}

func (s Chan_newSendCloser_Results) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Chan_newSendCloser_Results) DecodeFromPtr(p capnp.Ptr) Chan_newSendCloser_Results {
	return Chan_newSendCloser_Results(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Chan_newSendCloser_Results) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Chan_newSendCloser_Results) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Chan_newSendCloser_Results) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Chan_newSendCloser_Results) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Chan_newSendCloser_Results) SendCloser() SendCloser {
	p, _ := capnp.Struct(s).Ptr(0)
	return SendCloser(p.Interface().Client())
}

func (s Chan_newSendCloser_Results) HasSendCloser() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s Chan_newSendCloser_Results) SetSendCloser(v SendCloser) error {
	if !v.IsValid() {
		return capnp.Struct(s).SetPtr(0, capnp.Ptr{})
	}
	seg := s.Segment()
	in := capnp.NewInterface(seg, seg.Message().CapTable().Add(capnp.Client(v)))
	return capnp.Struct(s).SetPtr(0, in.ToPtr())
}

// Chan_newSendCloser_Results_List is a list of Chan_newSendCloser_Results.
type Chan_newSendCloser_Results_List = capnp.StructList[Chan_newSendCloser_Results]

// NewChan_newSendCloser_Results creates a new list of Chan_newSendCloser_Results.
func NewChan_newSendCloser_Results_List(s *capnp.Segment, sz int32) (Chan_newSendCloser_Results_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return capnp.StructList[Chan_newSendCloser_Results](l), err
}

// Chan_newSendCloser_Results_Future is a wrapper for a Chan_newSendCloser_Results promised by a client call.
type Chan_newSendCloser_Results_Future struct{ *capnp.Future }

func (f Chan_newSendCloser_Results_Future) Struct() (Chan_newSendCloser_Results, error) {
	p, err := f.Future.Ptr()
	return Chan_newSendCloser_Results(p.Struct()), err
}
func (p Chan_newSendCloser_Results_Future) SendCloser() SendCloser {
	return SendCloser(p.Future.Field(0, nil).Client())
}

type Chan_newRecver_Params capnp.Struct

// Chan_newRecver_Params_TypeID is the unique identifier for the type Chan_newRecver_Params.
const Chan_newRecver_Params_TypeID = 0x891b1d7a66ab36b5

func NewChan_newRecver_Params(s *capnp.Segment) (Chan_newRecver_Params, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return Chan_newRecver_Params(st), err
}

func NewRootChan_newRecver_Params(s *capnp.Segment) (Chan_newRecver_Params, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return Chan_newRecver_Params(st), err
}

func ReadRootChan_newRecver_Params(msg *capnp.Message) (Chan_newRecver_Params, error) {
	root, err := msg.Root()
	return Chan_newRecver_Params(root.Struct()), err
}

func (s Chan_newRecver_Params) String() string {
	str, _ := text.Marshal(0x891b1d7a66ab36b5, capnp.Struct(s))
	return str
}

func (s Chan_newRecver_Params) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Chan_newRecver_Params) DecodeFromPtr(p capnp.Ptr) Chan_newRecver_Params {
	return Chan_newRecver_Params(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Chan_newRecver_Params) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Chan_newRecver_Params) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Chan_newRecver_Params) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Chan_newRecver_Params) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}

// Chan_newRecver_Params_List is a list of Chan_newRecver_Params.
type Chan_newRecver_Params_List = capnp.StructList[Chan_newRecver_Params]

// NewChan_newRecver_Params creates a new list of Chan_newRecver_Params.
func NewChan_newRecver_Params_List(s *capnp.Segment, sz int32) (Chan_newRecver_Params_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0}, sz)
	return capnp.StructList[Chan_newRecver_Params](l), err
}

// Chan_newRecver_Params_Future is a wrapper for a Chan_newRecver_Params promised by a client call.
type Chan_newRecver_Params_Future struct{ *capnp.Future }

func (f Chan_newRecver_Params_Future) Struct() (Chan_newRecver_Params, error) {
	p, err := f.Future.Ptr()
	return Chan_newRecver_Params(p.Struct()), err
}

type Chan_newRecver_Results capnp.Struct

// Chan_newRecver_Results_TypeID is the unique identifier for the type Chan_newRecver_Results.
const Chan_newRecver_Results_TypeID = 0x9f8a81c20d0e72c9

func NewChan_newRecver_Results(s *capnp.Segment) (Chan_newRecver_Results, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Chan_newRecver_Results(st), err
}

func NewRootChan_newRecver_Results(s *capnp.Segment) (Chan_newRecver_Results, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Chan_newRecver_Results(st), err
}

func ReadRootChan_newRecver_Results(msg *capnp.Message) (Chan_newRecver_Results, error) {
	root, err := msg.Root()
	return Chan_newRecver_Results(root.Struct()), err
}

func (s Chan_newRecver_Results) String() string {
	str, _ := text.Marshal(0x9f8a81c20d0e72c9, capnp.Struct(s))
	return str
}

func (s Chan_newRecver_Results) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Chan_newRecver_Results) DecodeFromPtr(p capnp.Ptr) Chan_newRecver_Results {
	return Chan_newRecver_Results(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Chan_newRecver_Results) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Chan_newRecver_Results) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Chan_newRecver_Results) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Chan_newRecver_Results) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Chan_newRecver_Results) Recver() Recver {
	p, _ := capnp.Struct(s).Ptr(0)
	return Recver(p.Interface().Client())
}

func (s Chan_newRecver_Results) HasRecver() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s Chan_newRecver_Results) SetRecver(v Recver) error {
	if !v.IsValid() {
		return capnp.Struct(s).SetPtr(0, capnp.Ptr{})
	}
	seg := s.Segment()
	in := capnp.NewInterface(seg, seg.Message().CapTable().Add(capnp.Client(v)))
	return capnp.Struct(s).SetPtr(0, in.ToPtr())
}

// Chan_newRecver_Results_List is a list of Chan_newRecver_Results.
type Chan_newRecver_Results_List = capnp.StructList[Chan_newRecver_Results]

// NewChan_newRecver_Results creates a new list of Chan_newRecver_Results.
func NewChan_newRecver_Results_List(s *capnp.Segment, sz int32) (Chan_newRecver_Results_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return capnp.StructList[Chan_newRecver_Results](l), err
}

// Chan_newRecver_Results_Future is a wrapper for a Chan_newRecver_Results promised by a client call.
type Chan_newRecver_Results_Future struct{ *capnp.Future }

func (f Chan_newRecver_Results_Future) Struct() (Chan_newRecver_Results, error) {
	p, err := f.Future.Ptr()
	return Chan_newRecver_Results(p.Struct()), err
}
func (p Chan_newRecver_Results_Future) Recver() Recver {
	return Recver(p.Future.Field(0, nil).Client())
}

const schema_872a451f9aa74ebf = "x\xda\x94VQh\x1cU\x17>gg\xee\xdc\xfc!" +
	"\xdb\xc9\xdd\x9b\xbfR\xad\xacHk!\xe0\x92m\xa1\x91" +
	"\xa8d\xc7m\x89\x0a)\x99\xb5\x01-\xf5aH'\x16" +
	"\xdd\x8c\xedN\xd3\xdaJ\x1e\xf2\x14T\x8a/\xf5\xc1 " +
	"\x14A\xacM\x11\xfb\xa0\xa8\xa4 \x98\x17M#\xe8\x93" +
	"\x16\\J\xa1\xa5m4\x95\x80E\x14\xc2\xc8\x9d\xdd;" +
	"sww\xbau\x9f\x12\xee\xfd\xe6;\xe7|\xe7;\xf7" +
	"\xec\xc0\xc5TA\xcf\xa7\xff\xa0\x90\xb2\x0f\x12#X~" +
	"c\xed\xe9\x0f.M\xce\x02\xfb?\x02\x10\xa4\xbd\xb8\xab" +
	"\xaau# \xbf\xa1\x0d\x03\x06_\xec\xbe0y\xea\xe1" +
	"\x87\xde\x02\xc6\x11@\x17\xf7D\x7f\x14A\x0f\xec\xbf&" +
	"\xaf\xdc<\xfb\xdd{\xc06i\xc17\xfb\xce\xcdg\xf7" +
	"\xf6\xcf\x01@/\xf25m\x9e\xdf\xd5(\x00_\xd7\xe6" +
	"\xf8\xfb\xfa\x0e\xfe?b\x06\xdfW6\xa5\xbf\x9d}\xfb" +
	"l\x8d\xaa\x16kC\xef\x17\xb1\x08\x11\xb1\xcel\x1e\xea" +
	"\x1e}\xf7\xd6E5\x99q\x92\x11\x80\x97C\xc0o\x9f" +
	"?\xb2\xf2;\xe6\x17k\x800\x99\x19q\xaf\x07\xe7\x9f" +
	"\xfc\xe8\xe8Jzp\x11\xd8\x16y\xe3\x92\x92\xb8\x99\xbd" +
	"\x80E\xec=\xba\\\xbb\xa9\x91\xda\xe4@L:\xfe\x09" +
	"\xa6\x7f\x18\xbetYM\xebS\xf2\xbc\x00|\x1d\x02V" +
	"\xff<\xf5\xceg\x07\xef\\\x96Q\x01v\xa5\x8d\x07\x05" +
	"\xf7\xeac\xdb\xd2\xbf\xce\x0cV\x95|\xee\x92nqC" +
	"{\xb6\xbe\x92>O\xae&\x88S%\x0b\xfc\x06\x11\xe2" +
	"\\##<oP\x9e7\xcc\xe0\xf4\xc7\xaf])\x9e" +
	"9}])`\xbb\x11\x16pu\xe9\xe77\xafU_" +
	"\xbd\xa9t\x80\x19\xcf\x88\x9b;\x9bW\x9f\xe8[[\xbc" +
	"\x95\x10\xe4o\xb2\xc0\xd1\x10A6\xc8\x08\x1f5(\x1f" +
	"5\xcc`\xdf\xed\xbe\x99\xf9\x9f\xce\xddN\xf8\xc02\x96" +
	"\x05\x0c\x80?g\xcc\xf1uc\x07\xcfS3X\xdf\xb2" +
	"\xf4\xe5\xc9Bu]\x15o;\x0d\xc5\xcbS\xa1\xcd\xd2" +
	"\xc9\xc1\xf4W\xd7\x7f\xfc\xa7\x89\x11\xb9M\x17\xf8KT" +
	"\xf0\x8d\xd3\x11>#\xfe\x0b\x9ezq\xf7\xca\x87\xbf\xd0" +
	"\x0dEH\x97f\x10\x06\x82\x89\xc3\x8e\xe7\xb9\xe5\x9c6" +
	"\xe1\x1c\xf1\x8e\x0c\xbd\xe0z\x87\xdcJ\xcew\xbdC\xdb" +
	"\xc6\x9c\x8a3\xe5\x03\xd8\xba\xa6\x03\xe8\x08\xc0\xd2;\x01" +
	"\xec.\x0d\xed\xbe\x14f\x8f;\xe5i\x173\x88\xb1\x1c" +
	"\x00\x98\x01l&-\x1ev\xbc\x9c\xe7\x9e(\xb9\x13\xc7" +
	"\xdd\x8a\xe0\xa5\xce\x94\x1f\xa1P\xa24\xc7\x1bC\xb4\xbb" +
	"4\x02\x10\x89\x8f\xd2%,_\x01\xb0\x06\xd0* \xb3" +
	")\xc6\x03\x82\xd2\xdelo\x09\xc0\xda\x83\xd6~d." +
	"\x0d<\xf7\x84(\xa7\x08\xd9\xf2\xeb\xbe[a\x98\xb5\xf5" +
	"\x14\xc6\xd3\x83\xa2\xa2\xa4\xc3\x02\x062[\xc0\x8e\xbe\xb3" +
	"\xbb\x10\xe3^[]\x18\xdb\xd1\x1a@\xf9Q\x04\x10<" +
	"\x0f\xd8:\"\xe2\x98\x86\xa1\x94\x11a\x1c#\xa2h\x0f" +
	"\xb7td\x98\xc1\xfd\xf7Q\xbf\xe4\xfa\xe6t\xf9\x98\xaf" +
	"vu\xa8\xde\xd5=)\x1c\xae\x840dj\xd8\x02v" +
	"\x98\x0b\xb2V\x17\xd4\xe2\xe7\x04\xbfHb\xba|\x0c\xfd" +
	"\xfb[K\x09\x98d-\xd5\xaf\x924\xc2\xe81\xa6\x18" +
	"Z W\xb7D\xcd\x84\xce\xd4\x7f\xc4\x86\xc4\xda\xbd%" +
	"\xf3C\x182u\x0eb\xc9\x94\xc3\x16\xc9\x14'4H" +
	"\xa67\xb6.\xce\xaa^d\xd3T\x1e\x00\xb0{4\xb4" +
	"\x9fMa\xe0\xd7\xb1\xa0\x85))\x11\x0a\x9d\x1a0\xa9" +
	"\x8buq&\xc4\x9fH\x98v\xad\x96\xafH\xf3\xb8\x97" +
	"\\S\x80\xc4\xc0\xeb\xe1\xc0\xcb'\x1d\xe52b\xac\x1f" +
	"\xc0\xeaAk+\xb2\xc7\xa9)\xd8Zl\xa8\xceb\xc3" +
	"a\x01\xc7\x10[F\"\xb1\xcbue\x9b\x1da\xdc\xb3" +
	"\x07\xf5\x92$Pr\x9a\xc2\x05q=r\xc1\xa3\xdc\x9d" +
	"M\xf5\x88F\xb5xD\xad\xa7\xe10\xb9\x9eTs=" +
	"\x00\xf1\x0b*73\xcaE\xcc\xf2\xa5\xc6\x17T\xae>" +
	"\x94\xdb&\xf9\x05U_\xc1\xc8:j\xa6\x0d\x87\xb5\xd7" +
	"3L\xa7\xc3\xef\xc2\xd73\xaaZ\xbc\x9e\xd1\x92KP" +
	"\xa5\xfd8u\xd4\xfav\x03\xde\x97\xc2\xe1\xd0\xedb\x9a" +
	"\xe2|\xb0a8\xe4\x0a+\x9b\x02\x18{@\xee]\x94" +
	"\xbfd\x18\xdb\x09)Fh6\xa4\x0c\x9b\xdav\xc2\xea" +
	"\xa6\xfc7\x00\x00\xff\xff\xda\x9e\xfa="

func RegisterSchema(reg *schemas.Registry) {
	reg.Register(&schemas.Schema{
		String: schema_872a451f9aa74ebf,
		Nodes: []uint64{
			0x8166bc9c3ded78ca,
			0x891b1d7a66ab36b5,
			0x95c89fe7d966f751,
			0x9f8a81c20d0e72c9,
			0xb0e88f4d0a3a1694,
			0xbb3101eccc20b4eb,
			0xbb370dcc71a43ba9,
			0xca7110014301ab81,
			0xcbbc3fcd0d01a855,
			0xcbee5caf8b7af4ea,
			0xdd377ddc0d2426ea,
			0xdf05a90d671c0c07,
			0xe48d9443d96ba68d,
			0xe76adde17bd7c3df,
			0xe8bbed1438ea16ee,
			0xe9a7d19a7d14e94e,
			0xf1dd4079b7c319f1,
			0xfad0e4b80d3779c3,
			0xfd07d8a1cc36583c,
		},
		Compressed: true,
	})
}
