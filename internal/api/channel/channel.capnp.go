// Code generated by capnpc-go. DO NOT EDIT.

package channel

import (
	capnp "capnproto.org/go/capnp/v3"
	text "capnproto.org/go/capnp/v3/encoding/text"
	schemas "capnproto.org/go/capnp/v3/schemas"
	server "capnproto.org/go/capnp/v3/server"
	context "context"
)

type Closer struct{ Client *capnp.Client }

// Closer_TypeID is the unique identifier for the type Closer.
const Closer_TypeID = 0xfad0e4b80d3779c3

func (c Closer) Close(ctx context.Context, params func(Closer_close_Params) error) (Closer_close_Results_Future, capnp.ReleaseFunc) {
	s := capnp.Send{
		Method: capnp.Method{
			InterfaceID:   0xfad0e4b80d3779c3,
			MethodID:      0,
			InterfaceName: "channel.capnp:Closer",
			MethodName:    "close",
		},
	}
	if params != nil {
		s.ArgsSize = capnp.ObjectSize{DataSize: 0, PointerCount: 0}
		s.PlaceArgs = func(s capnp.Struct) error { return params(Closer_close_Params{Struct: s}) }
	}
	ans, release := c.Client.SendCall(ctx, s)
	return Closer_close_Results_Future{Future: ans.Future()}, release
}

func (c Closer) AddRef() Closer {
	return Closer{
		Client: c.Client.AddRef(),
	}
}

func (c Closer) Release() {
	c.Client.Release()
}

// A Closer_Server is a Closer with a local implementation.
type Closer_Server interface {
	Close(context.Context, Closer_close) error
}

// Closer_NewServer creates a new Server from an implementation of Closer_Server.
func Closer_NewServer(s Closer_Server, policy *server.Policy) *server.Server {
	c, _ := s.(server.Shutdowner)
	return server.New(Closer_Methods(nil, s), s, c, policy)
}

// Closer_ServerToClient creates a new Client from an implementation of Closer_Server.
// The caller is responsible for calling Release on the returned Client.
func Closer_ServerToClient(s Closer_Server, policy *server.Policy) Closer {
	return Closer{Client: capnp.NewClient(Closer_NewServer(s, policy))}
}

// Closer_Methods appends Methods to a slice that invoke the methods on s.
// This can be used to create a more complicated Server.
func Closer_Methods(methods []server.Method, s Closer_Server) []server.Method {
	if cap(methods) == 0 {
		methods = make([]server.Method, 0, 1)
	}

	methods = append(methods, server.Method{
		Method: capnp.Method{
			InterfaceID:   0xfad0e4b80d3779c3,
			MethodID:      0,
			InterfaceName: "channel.capnp:Closer",
			MethodName:    "close",
		},
		Impl: func(ctx context.Context, call *server.Call) error {
			return s.Close(ctx, Closer_close{call})
		},
	})

	return methods
}

// Closer_close holds the state for a server call to Closer.close.
// See server.Call for documentation.
type Closer_close struct {
	*server.Call
}

// Args returns the call's arguments.
func (c Closer_close) Args() Closer_close_Params {
	return Closer_close_Params{Struct: c.Call.Args()}
}

// AllocResults allocates the results struct.
func (c Closer_close) AllocResults() (Closer_close_Results, error) {
	r, err := c.Call.AllocResults(capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return Closer_close_Results{Struct: r}, err
}

type Closer_close_Params struct{ capnp.Struct }

// Closer_close_Params_TypeID is the unique identifier for the type Closer_close_Params.
const Closer_close_Params_TypeID = 0xfd07d8a1cc36583c

func NewCloser_close_Params(s *capnp.Segment) (Closer_close_Params, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return Closer_close_Params{st}, err
}

func NewRootCloser_close_Params(s *capnp.Segment) (Closer_close_Params, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return Closer_close_Params{st}, err
}

func ReadRootCloser_close_Params(msg *capnp.Message) (Closer_close_Params, error) {
	root, err := msg.Root()
	return Closer_close_Params{root.Struct()}, err
}

func (s Closer_close_Params) String() string {
	str, _ := text.Marshal(0xfd07d8a1cc36583c, s.Struct)
	return str
}

// Closer_close_Params_List is a list of Closer_close_Params.
type Closer_close_Params_List = capnp.StructList[Closer_close_Params]

// NewCloser_close_Params creates a new list of Closer_close_Params.
func NewCloser_close_Params_List(s *capnp.Segment, sz int32) (Closer_close_Params_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0}, sz)
	return capnp.StructList[Closer_close_Params]{List: l}, err
}

// Closer_close_Params_Future is a wrapper for a Closer_close_Params promised by a client call.
type Closer_close_Params_Future struct{ *capnp.Future }

func (p Closer_close_Params_Future) Struct() (Closer_close_Params, error) {
	s, err := p.Future.Struct()
	return Closer_close_Params{s}, err
}

type Closer_close_Results struct{ capnp.Struct }

// Closer_close_Results_TypeID is the unique identifier for the type Closer_close_Results.
const Closer_close_Results_TypeID = 0xcbee5caf8b7af4ea

func NewCloser_close_Results(s *capnp.Segment) (Closer_close_Results, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return Closer_close_Results{st}, err
}

func NewRootCloser_close_Results(s *capnp.Segment) (Closer_close_Results, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return Closer_close_Results{st}, err
}

func ReadRootCloser_close_Results(msg *capnp.Message) (Closer_close_Results, error) {
	root, err := msg.Root()
	return Closer_close_Results{root.Struct()}, err
}

func (s Closer_close_Results) String() string {
	str, _ := text.Marshal(0xcbee5caf8b7af4ea, s.Struct)
	return str
}

// Closer_close_Results_List is a list of Closer_close_Results.
type Closer_close_Results_List = capnp.StructList[Closer_close_Results]

// NewCloser_close_Results creates a new list of Closer_close_Results.
func NewCloser_close_Results_List(s *capnp.Segment, sz int32) (Closer_close_Results_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0}, sz)
	return capnp.StructList[Closer_close_Results]{List: l}, err
}

// Closer_close_Results_Future is a wrapper for a Closer_close_Results promised by a client call.
type Closer_close_Results_Future struct{ *capnp.Future }

func (p Closer_close_Results_Future) Struct() (Closer_close_Results, error) {
	s, err := p.Future.Struct()
	return Closer_close_Results{s}, err
}

type Sender struct{ Client *capnp.Client }

// Sender_TypeID is the unique identifier for the type Sender.
const Sender_TypeID = 0xe8bbed1438ea16ee

func (c Sender) Send(ctx context.Context, params func(Sender_send_Params) error) (Sender_send_Results_Future, capnp.ReleaseFunc) {
	s := capnp.Send{
		Method: capnp.Method{
			InterfaceID:   0xe8bbed1438ea16ee,
			MethodID:      0,
			InterfaceName: "channel.capnp:Sender",
			MethodName:    "send",
		},
	}
	if params != nil {
		s.ArgsSize = capnp.ObjectSize{DataSize: 0, PointerCount: 1}
		s.PlaceArgs = func(s capnp.Struct) error { return params(Sender_send_Params{Struct: s}) }
	}
	ans, release := c.Client.SendCall(ctx, s)
	return Sender_send_Results_Future{Future: ans.Future()}, release
}

func (c Sender) AddRef() Sender {
	return Sender{
		Client: c.Client.AddRef(),
	}
}

func (c Sender) Release() {
	c.Client.Release()
}

// A Sender_Server is a Sender with a local implementation.
type Sender_Server interface {
	Send(context.Context, Sender_send) error
}

// Sender_NewServer creates a new Server from an implementation of Sender_Server.
func Sender_NewServer(s Sender_Server, policy *server.Policy) *server.Server {
	c, _ := s.(server.Shutdowner)
	return server.New(Sender_Methods(nil, s), s, c, policy)
}

// Sender_ServerToClient creates a new Client from an implementation of Sender_Server.
// The caller is responsible for calling Release on the returned Client.
func Sender_ServerToClient(s Sender_Server, policy *server.Policy) Sender {
	return Sender{Client: capnp.NewClient(Sender_NewServer(s, policy))}
}

// Sender_Methods appends Methods to a slice that invoke the methods on s.
// This can be used to create a more complicated Server.
func Sender_Methods(methods []server.Method, s Sender_Server) []server.Method {
	if cap(methods) == 0 {
		methods = make([]server.Method, 0, 1)
	}

	methods = append(methods, server.Method{
		Method: capnp.Method{
			InterfaceID:   0xe8bbed1438ea16ee,
			MethodID:      0,
			InterfaceName: "channel.capnp:Sender",
			MethodName:    "send",
		},
		Impl: func(ctx context.Context, call *server.Call) error {
			return s.Send(ctx, Sender_send{call})
		},
	})

	return methods
}

// Sender_send holds the state for a server call to Sender.send.
// See server.Call for documentation.
type Sender_send struct {
	*server.Call
}

// Args returns the call's arguments.
func (c Sender_send) Args() Sender_send_Params {
	return Sender_send_Params{Struct: c.Call.Args()}
}

// AllocResults allocates the results struct.
func (c Sender_send) AllocResults() (Sender_send_Results, error) {
	r, err := c.Call.AllocResults(capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return Sender_send_Results{Struct: r}, err
}

type Sender_send_Params struct{ capnp.Struct }

// Sender_send_Params_TypeID is the unique identifier for the type Sender_send_Params.
const Sender_send_Params_TypeID = 0x8166bc9c3ded78ca

func NewSender_send_Params(s *capnp.Segment) (Sender_send_Params, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Sender_send_Params{st}, err
}

func NewRootSender_send_Params(s *capnp.Segment) (Sender_send_Params, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Sender_send_Params{st}, err
}

func ReadRootSender_send_Params(msg *capnp.Message) (Sender_send_Params, error) {
	root, err := msg.Root()
	return Sender_send_Params{root.Struct()}, err
}

func (s Sender_send_Params) String() string {
	str, _ := text.Marshal(0x8166bc9c3ded78ca, s.Struct)
	return str
}

func (s Sender_send_Params) Value() (capnp.Ptr, error) {
	return s.Struct.Ptr(0)
}

func (s Sender_send_Params) HasValue() bool {
	return s.Struct.HasPtr(0)
}

func (s Sender_send_Params) SetValue(v capnp.Ptr) error {
	return s.Struct.SetPtr(0, v)
}

// Sender_send_Params_List is a list of Sender_send_Params.
type Sender_send_Params_List = capnp.StructList[Sender_send_Params]

// NewSender_send_Params creates a new list of Sender_send_Params.
func NewSender_send_Params_List(s *capnp.Segment, sz int32) (Sender_send_Params_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return capnp.StructList[Sender_send_Params]{List: l}, err
}

// Sender_send_Params_Future is a wrapper for a Sender_send_Params promised by a client call.
type Sender_send_Params_Future struct{ *capnp.Future }

func (p Sender_send_Params_Future) Struct() (Sender_send_Params, error) {
	s, err := p.Future.Struct()
	return Sender_send_Params{s}, err
}

func (p Sender_send_Params_Future) Value() *capnp.Future {
	return p.Future.Field(0, nil)
}

type Sender_send_Results struct{ capnp.Struct }

// Sender_send_Results_TypeID is the unique identifier for the type Sender_send_Results.
const Sender_send_Results_TypeID = 0xbb3101eccc20b4eb

func NewSender_send_Results(s *capnp.Segment) (Sender_send_Results, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return Sender_send_Results{st}, err
}

func NewRootSender_send_Results(s *capnp.Segment) (Sender_send_Results, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return Sender_send_Results{st}, err
}

func ReadRootSender_send_Results(msg *capnp.Message) (Sender_send_Results, error) {
	root, err := msg.Root()
	return Sender_send_Results{root.Struct()}, err
}

func (s Sender_send_Results) String() string {
	str, _ := text.Marshal(0xbb3101eccc20b4eb, s.Struct)
	return str
}

// Sender_send_Results_List is a list of Sender_send_Results.
type Sender_send_Results_List = capnp.StructList[Sender_send_Results]

// NewSender_send_Results creates a new list of Sender_send_Results.
func NewSender_send_Results_List(s *capnp.Segment, sz int32) (Sender_send_Results_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0}, sz)
	return capnp.StructList[Sender_send_Results]{List: l}, err
}

// Sender_send_Results_Future is a wrapper for a Sender_send_Results promised by a client call.
type Sender_send_Results_Future struct{ *capnp.Future }

func (p Sender_send_Results_Future) Struct() (Sender_send_Results, error) {
	s, err := p.Future.Struct()
	return Sender_send_Results{s}, err
}

type Peeker struct{ Client *capnp.Client }

// Peeker_TypeID is the unique identifier for the type Peeker.
const Peeker_TypeID = 0xe95c7f9f41bf520a

func (c Peeker) Peek(ctx context.Context, params func(Peeker_peek_Params) error) (Peeker_peek_Results_Future, capnp.ReleaseFunc) {
	s := capnp.Send{
		Method: capnp.Method{
			InterfaceID:   0xe95c7f9f41bf520a,
			MethodID:      0,
			InterfaceName: "channel.capnp:Peeker",
			MethodName:    "peek",
		},
	}
	if params != nil {
		s.ArgsSize = capnp.ObjectSize{DataSize: 0, PointerCount: 0}
		s.PlaceArgs = func(s capnp.Struct) error { return params(Peeker_peek_Params{Struct: s}) }
	}
	ans, release := c.Client.SendCall(ctx, s)
	return Peeker_peek_Results_Future{Future: ans.Future()}, release
}

func (c Peeker) AddRef() Peeker {
	return Peeker{
		Client: c.Client.AddRef(),
	}
}

func (c Peeker) Release() {
	c.Client.Release()
}

// A Peeker_Server is a Peeker with a local implementation.
type Peeker_Server interface {
	Peek(context.Context, Peeker_peek) error
}

// Peeker_NewServer creates a new Server from an implementation of Peeker_Server.
func Peeker_NewServer(s Peeker_Server, policy *server.Policy) *server.Server {
	c, _ := s.(server.Shutdowner)
	return server.New(Peeker_Methods(nil, s), s, c, policy)
}

// Peeker_ServerToClient creates a new Client from an implementation of Peeker_Server.
// The caller is responsible for calling Release on the returned Client.
func Peeker_ServerToClient(s Peeker_Server, policy *server.Policy) Peeker {
	return Peeker{Client: capnp.NewClient(Peeker_NewServer(s, policy))}
}

// Peeker_Methods appends Methods to a slice that invoke the methods on s.
// This can be used to create a more complicated Server.
func Peeker_Methods(methods []server.Method, s Peeker_Server) []server.Method {
	if cap(methods) == 0 {
		methods = make([]server.Method, 0, 1)
	}

	methods = append(methods, server.Method{
		Method: capnp.Method{
			InterfaceID:   0xe95c7f9f41bf520a,
			MethodID:      0,
			InterfaceName: "channel.capnp:Peeker",
			MethodName:    "peek",
		},
		Impl: func(ctx context.Context, call *server.Call) error {
			return s.Peek(ctx, Peeker_peek{call})
		},
	})

	return methods
}

// Peeker_peek holds the state for a server call to Peeker.peek.
// See server.Call for documentation.
type Peeker_peek struct {
	*server.Call
}

// Args returns the call's arguments.
func (c Peeker_peek) Args() Peeker_peek_Params {
	return Peeker_peek_Params{Struct: c.Call.Args()}
}

// AllocResults allocates the results struct.
func (c Peeker_peek) AllocResults() (Peeker_peek_Results, error) {
	r, err := c.Call.AllocResults(capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Peeker_peek_Results{Struct: r}, err
}

type Peeker_peek_Params struct{ capnp.Struct }

// Peeker_peek_Params_TypeID is the unique identifier for the type Peeker_peek_Params.
const Peeker_peek_Params_TypeID = 0xaf261efa7a102288

func NewPeeker_peek_Params(s *capnp.Segment) (Peeker_peek_Params, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return Peeker_peek_Params{st}, err
}

func NewRootPeeker_peek_Params(s *capnp.Segment) (Peeker_peek_Params, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return Peeker_peek_Params{st}, err
}

func ReadRootPeeker_peek_Params(msg *capnp.Message) (Peeker_peek_Params, error) {
	root, err := msg.Root()
	return Peeker_peek_Params{root.Struct()}, err
}

func (s Peeker_peek_Params) String() string {
	str, _ := text.Marshal(0xaf261efa7a102288, s.Struct)
	return str
}

// Peeker_peek_Params_List is a list of Peeker_peek_Params.
type Peeker_peek_Params_List = capnp.StructList[Peeker_peek_Params]

// NewPeeker_peek_Params creates a new list of Peeker_peek_Params.
func NewPeeker_peek_Params_List(s *capnp.Segment, sz int32) (Peeker_peek_Params_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0}, sz)
	return capnp.StructList[Peeker_peek_Params]{List: l}, err
}

// Peeker_peek_Params_Future is a wrapper for a Peeker_peek_Params promised by a client call.
type Peeker_peek_Params_Future struct{ *capnp.Future }

func (p Peeker_peek_Params_Future) Struct() (Peeker_peek_Params, error) {
	s, err := p.Future.Struct()
	return Peeker_peek_Params{s}, err
}

type Peeker_peek_Results struct{ capnp.Struct }

// Peeker_peek_Results_TypeID is the unique identifier for the type Peeker_peek_Results.
const Peeker_peek_Results_TypeID = 0xb42eee8bed32bea0

func NewPeeker_peek_Results(s *capnp.Segment) (Peeker_peek_Results, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Peeker_peek_Results{st}, err
}

func NewRootPeeker_peek_Results(s *capnp.Segment) (Peeker_peek_Results, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Peeker_peek_Results{st}, err
}

func ReadRootPeeker_peek_Results(msg *capnp.Message) (Peeker_peek_Results, error) {
	root, err := msg.Root()
	return Peeker_peek_Results{root.Struct()}, err
}

func (s Peeker_peek_Results) String() string {
	str, _ := text.Marshal(0xb42eee8bed32bea0, s.Struct)
	return str
}

func (s Peeker_peek_Results) Value() (capnp.Ptr, error) {
	return s.Struct.Ptr(0)
}

func (s Peeker_peek_Results) HasValue() bool {
	return s.Struct.HasPtr(0)
}

func (s Peeker_peek_Results) SetValue(v capnp.Ptr) error {
	return s.Struct.SetPtr(0, v)
}

// Peeker_peek_Results_List is a list of Peeker_peek_Results.
type Peeker_peek_Results_List = capnp.StructList[Peeker_peek_Results]

// NewPeeker_peek_Results creates a new list of Peeker_peek_Results.
func NewPeeker_peek_Results_List(s *capnp.Segment, sz int32) (Peeker_peek_Results_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return capnp.StructList[Peeker_peek_Results]{List: l}, err
}

// Peeker_peek_Results_Future is a wrapper for a Peeker_peek_Results promised by a client call.
type Peeker_peek_Results_Future struct{ *capnp.Future }

func (p Peeker_peek_Results_Future) Struct() (Peeker_peek_Results, error) {
	s, err := p.Future.Struct()
	return Peeker_peek_Results{s}, err
}

func (p Peeker_peek_Results_Future) Value() *capnp.Future {
	return p.Future.Field(0, nil)
}

type Recver struct{ Client *capnp.Client }

// Recver_TypeID is the unique identifier for the type Recver.
const Recver_TypeID = 0xdf05a90d671c0c07

func (c Recver) Recv(ctx context.Context, params func(Recver_recv_Params) error) (Recver_recv_Results_Future, capnp.ReleaseFunc) {
	s := capnp.Send{
		Method: capnp.Method{
			InterfaceID:   0xdf05a90d671c0c07,
			MethodID:      0,
			InterfaceName: "channel.capnp:Recver",
			MethodName:    "recv",
		},
	}
	if params != nil {
		s.ArgsSize = capnp.ObjectSize{DataSize: 0, PointerCount: 0}
		s.PlaceArgs = func(s capnp.Struct) error { return params(Recver_recv_Params{Struct: s}) }
	}
	ans, release := c.Client.SendCall(ctx, s)
	return Recver_recv_Results_Future{Future: ans.Future()}, release
}

func (c Recver) AddRef() Recver {
	return Recver{
		Client: c.Client.AddRef(),
	}
}

func (c Recver) Release() {
	c.Client.Release()
}

// A Recver_Server is a Recver with a local implementation.
type Recver_Server interface {
	Recv(context.Context, Recver_recv) error
}

// Recver_NewServer creates a new Server from an implementation of Recver_Server.
func Recver_NewServer(s Recver_Server, policy *server.Policy) *server.Server {
	c, _ := s.(server.Shutdowner)
	return server.New(Recver_Methods(nil, s), s, c, policy)
}

// Recver_ServerToClient creates a new Client from an implementation of Recver_Server.
// The caller is responsible for calling Release on the returned Client.
func Recver_ServerToClient(s Recver_Server, policy *server.Policy) Recver {
	return Recver{Client: capnp.NewClient(Recver_NewServer(s, policy))}
}

// Recver_Methods appends Methods to a slice that invoke the methods on s.
// This can be used to create a more complicated Server.
func Recver_Methods(methods []server.Method, s Recver_Server) []server.Method {
	if cap(methods) == 0 {
		methods = make([]server.Method, 0, 1)
	}

	methods = append(methods, server.Method{
		Method: capnp.Method{
			InterfaceID:   0xdf05a90d671c0c07,
			MethodID:      0,
			InterfaceName: "channel.capnp:Recver",
			MethodName:    "recv",
		},
		Impl: func(ctx context.Context, call *server.Call) error {
			return s.Recv(ctx, Recver_recv{call})
		},
	})

	return methods
}

// Recver_recv holds the state for a server call to Recver.recv.
// See server.Call for documentation.
type Recver_recv struct {
	*server.Call
}

// Args returns the call's arguments.
func (c Recver_recv) Args() Recver_recv_Params {
	return Recver_recv_Params{Struct: c.Call.Args()}
}

// AllocResults allocates the results struct.
func (c Recver_recv) AllocResults() (Recver_recv_Results, error) {
	r, err := c.Call.AllocResults(capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Recver_recv_Results{Struct: r}, err
}

type Recver_recv_Params struct{ capnp.Struct }

// Recver_recv_Params_TypeID is the unique identifier for the type Recver_recv_Params.
const Recver_recv_Params_TypeID = 0xdd377ddc0d2426ea

func NewRecver_recv_Params(s *capnp.Segment) (Recver_recv_Params, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return Recver_recv_Params{st}, err
}

func NewRootRecver_recv_Params(s *capnp.Segment) (Recver_recv_Params, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return Recver_recv_Params{st}, err
}

func ReadRootRecver_recv_Params(msg *capnp.Message) (Recver_recv_Params, error) {
	root, err := msg.Root()
	return Recver_recv_Params{root.Struct()}, err
}

func (s Recver_recv_Params) String() string {
	str, _ := text.Marshal(0xdd377ddc0d2426ea, s.Struct)
	return str
}

// Recver_recv_Params_List is a list of Recver_recv_Params.
type Recver_recv_Params_List = capnp.StructList[Recver_recv_Params]

// NewRecver_recv_Params creates a new list of Recver_recv_Params.
func NewRecver_recv_Params_List(s *capnp.Segment, sz int32) (Recver_recv_Params_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0}, sz)
	return capnp.StructList[Recver_recv_Params]{List: l}, err
}

// Recver_recv_Params_Future is a wrapper for a Recver_recv_Params promised by a client call.
type Recver_recv_Params_Future struct{ *capnp.Future }

func (p Recver_recv_Params_Future) Struct() (Recver_recv_Params, error) {
	s, err := p.Future.Struct()
	return Recver_recv_Params{s}, err
}

type Recver_recv_Results struct{ capnp.Struct }

// Recver_recv_Results_TypeID is the unique identifier for the type Recver_recv_Results.
const Recver_recv_Results_TypeID = 0xb0e88f4d0a3a1694

func NewRecver_recv_Results(s *capnp.Segment) (Recver_recv_Results, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Recver_recv_Results{st}, err
}

func NewRootRecver_recv_Results(s *capnp.Segment) (Recver_recv_Results, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Recver_recv_Results{st}, err
}

func ReadRootRecver_recv_Results(msg *capnp.Message) (Recver_recv_Results, error) {
	root, err := msg.Root()
	return Recver_recv_Results{root.Struct()}, err
}

func (s Recver_recv_Results) String() string {
	str, _ := text.Marshal(0xb0e88f4d0a3a1694, s.Struct)
	return str
}

func (s Recver_recv_Results) Value() (capnp.Ptr, error) {
	return s.Struct.Ptr(0)
}

func (s Recver_recv_Results) HasValue() bool {
	return s.Struct.HasPtr(0)
}

func (s Recver_recv_Results) SetValue(v capnp.Ptr) error {
	return s.Struct.SetPtr(0, v)
}

// Recver_recv_Results_List is a list of Recver_recv_Results.
type Recver_recv_Results_List = capnp.StructList[Recver_recv_Results]

// NewRecver_recv_Results creates a new list of Recver_recv_Results.
func NewRecver_recv_Results_List(s *capnp.Segment, sz int32) (Recver_recv_Results_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return capnp.StructList[Recver_recv_Results]{List: l}, err
}

// Recver_recv_Results_Future is a wrapper for a Recver_recv_Results promised by a client call.
type Recver_recv_Results_Future struct{ *capnp.Future }

func (p Recver_recv_Results_Future) Struct() (Recver_recv_Results, error) {
	s, err := p.Future.Struct()
	return Recver_recv_Results{s}, err
}

func (p Recver_recv_Results_Future) Value() *capnp.Future {
	return p.Future.Field(0, nil)
}

type SendCloser struct{ Client *capnp.Client }

// SendCloser_TypeID is the unique identifier for the type SendCloser.
const SendCloser_TypeID = 0xe9a7d19a7d14e94e

func (c SendCloser) Send(ctx context.Context, params func(Sender_send_Params) error) (Sender_send_Results_Future, capnp.ReleaseFunc) {
	s := capnp.Send{
		Method: capnp.Method{
			InterfaceID:   0xe8bbed1438ea16ee,
			MethodID:      0,
			InterfaceName: "channel.capnp:Sender",
			MethodName:    "send",
		},
	}
	if params != nil {
		s.ArgsSize = capnp.ObjectSize{DataSize: 0, PointerCount: 1}
		s.PlaceArgs = func(s capnp.Struct) error { return params(Sender_send_Params{Struct: s}) }
	}
	ans, release := c.Client.SendCall(ctx, s)
	return Sender_send_Results_Future{Future: ans.Future()}, release
}
func (c SendCloser) Close(ctx context.Context, params func(Closer_close_Params) error) (Closer_close_Results_Future, capnp.ReleaseFunc) {
	s := capnp.Send{
		Method: capnp.Method{
			InterfaceID:   0xfad0e4b80d3779c3,
			MethodID:      0,
			InterfaceName: "channel.capnp:Closer",
			MethodName:    "close",
		},
	}
	if params != nil {
		s.ArgsSize = capnp.ObjectSize{DataSize: 0, PointerCount: 0}
		s.PlaceArgs = func(s capnp.Struct) error { return params(Closer_close_Params{Struct: s}) }
	}
	ans, release := c.Client.SendCall(ctx, s)
	return Closer_close_Results_Future{Future: ans.Future()}, release
}

func (c SendCloser) AddRef() SendCloser {
	return SendCloser{
		Client: c.Client.AddRef(),
	}
}

func (c SendCloser) Release() {
	c.Client.Release()
}

// A SendCloser_Server is a SendCloser with a local implementation.
type SendCloser_Server interface {
	Send(context.Context, Sender_send) error

	Close(context.Context, Closer_close) error
}

// SendCloser_NewServer creates a new Server from an implementation of SendCloser_Server.
func SendCloser_NewServer(s SendCloser_Server, policy *server.Policy) *server.Server {
	c, _ := s.(server.Shutdowner)
	return server.New(SendCloser_Methods(nil, s), s, c, policy)
}

// SendCloser_ServerToClient creates a new Client from an implementation of SendCloser_Server.
// The caller is responsible for calling Release on the returned Client.
func SendCloser_ServerToClient(s SendCloser_Server, policy *server.Policy) SendCloser {
	return SendCloser{Client: capnp.NewClient(SendCloser_NewServer(s, policy))}
}

// SendCloser_Methods appends Methods to a slice that invoke the methods on s.
// This can be used to create a more complicated Server.
func SendCloser_Methods(methods []server.Method, s SendCloser_Server) []server.Method {
	if cap(methods) == 0 {
		methods = make([]server.Method, 0, 2)
	}

	methods = append(methods, server.Method{
		Method: capnp.Method{
			InterfaceID:   0xe8bbed1438ea16ee,
			MethodID:      0,
			InterfaceName: "channel.capnp:Sender",
			MethodName:    "send",
		},
		Impl: func(ctx context.Context, call *server.Call) error {
			return s.Send(ctx, Sender_send{call})
		},
	})

	methods = append(methods, server.Method{
		Method: capnp.Method{
			InterfaceID:   0xfad0e4b80d3779c3,
			MethodID:      0,
			InterfaceName: "channel.capnp:Closer",
			MethodName:    "close",
		},
		Impl: func(ctx context.Context, call *server.Call) error {
			return s.Close(ctx, Closer_close{call})
		},
	})

	return methods
}

type PeekRecver struct{ Client *capnp.Client }

// PeekRecver_TypeID is the unique identifier for the type PeekRecver.
const PeekRecver_TypeID = 0x9a4abff8ccb5093c

func (c PeekRecver) Peek(ctx context.Context, params func(Peeker_peek_Params) error) (Peeker_peek_Results_Future, capnp.ReleaseFunc) {
	s := capnp.Send{
		Method: capnp.Method{
			InterfaceID:   0xe95c7f9f41bf520a,
			MethodID:      0,
			InterfaceName: "channel.capnp:Peeker",
			MethodName:    "peek",
		},
	}
	if params != nil {
		s.ArgsSize = capnp.ObjectSize{DataSize: 0, PointerCount: 0}
		s.PlaceArgs = func(s capnp.Struct) error { return params(Peeker_peek_Params{Struct: s}) }
	}
	ans, release := c.Client.SendCall(ctx, s)
	return Peeker_peek_Results_Future{Future: ans.Future()}, release
}
func (c PeekRecver) Recv(ctx context.Context, params func(Recver_recv_Params) error) (Recver_recv_Results_Future, capnp.ReleaseFunc) {
	s := capnp.Send{
		Method: capnp.Method{
			InterfaceID:   0xdf05a90d671c0c07,
			MethodID:      0,
			InterfaceName: "channel.capnp:Recver",
			MethodName:    "recv",
		},
	}
	if params != nil {
		s.ArgsSize = capnp.ObjectSize{DataSize: 0, PointerCount: 0}
		s.PlaceArgs = func(s capnp.Struct) error { return params(Recver_recv_Params{Struct: s}) }
	}
	ans, release := c.Client.SendCall(ctx, s)
	return Recver_recv_Results_Future{Future: ans.Future()}, release
}

func (c PeekRecver) AddRef() PeekRecver {
	return PeekRecver{
		Client: c.Client.AddRef(),
	}
}

func (c PeekRecver) Release() {
	c.Client.Release()
}

// A PeekRecver_Server is a PeekRecver with a local implementation.
type PeekRecver_Server interface {
	Peek(context.Context, Peeker_peek) error

	Recv(context.Context, Recver_recv) error
}

// PeekRecver_NewServer creates a new Server from an implementation of PeekRecver_Server.
func PeekRecver_NewServer(s PeekRecver_Server, policy *server.Policy) *server.Server {
	c, _ := s.(server.Shutdowner)
	return server.New(PeekRecver_Methods(nil, s), s, c, policy)
}

// PeekRecver_ServerToClient creates a new Client from an implementation of PeekRecver_Server.
// The caller is responsible for calling Release on the returned Client.
func PeekRecver_ServerToClient(s PeekRecver_Server, policy *server.Policy) PeekRecver {
	return PeekRecver{Client: capnp.NewClient(PeekRecver_NewServer(s, policy))}
}

// PeekRecver_Methods appends Methods to a slice that invoke the methods on s.
// This can be used to create a more complicated Server.
func PeekRecver_Methods(methods []server.Method, s PeekRecver_Server) []server.Method {
	if cap(methods) == 0 {
		methods = make([]server.Method, 0, 2)
	}

	methods = append(methods, server.Method{
		Method: capnp.Method{
			InterfaceID:   0xe95c7f9f41bf520a,
			MethodID:      0,
			InterfaceName: "channel.capnp:Peeker",
			MethodName:    "peek",
		},
		Impl: func(ctx context.Context, call *server.Call) error {
			return s.Peek(ctx, Peeker_peek{call})
		},
	})

	methods = append(methods, server.Method{
		Method: capnp.Method{
			InterfaceID:   0xdf05a90d671c0c07,
			MethodID:      0,
			InterfaceName: "channel.capnp:Recver",
			MethodName:    "recv",
		},
		Impl: func(ctx context.Context, call *server.Call) error {
			return s.Recv(ctx, Recver_recv{call})
		},
	})

	return methods
}

type Chan struct{ Client *capnp.Client }

// Chan_TypeID is the unique identifier for the type Chan.
const Chan_TypeID = 0x95c89fe7d966f751

func (c Chan) Send(ctx context.Context, params func(Sender_send_Params) error) (Sender_send_Results_Future, capnp.ReleaseFunc) {
	s := capnp.Send{
		Method: capnp.Method{
			InterfaceID:   0xe8bbed1438ea16ee,
			MethodID:      0,
			InterfaceName: "channel.capnp:Sender",
			MethodName:    "send",
		},
	}
	if params != nil {
		s.ArgsSize = capnp.ObjectSize{DataSize: 0, PointerCount: 1}
		s.PlaceArgs = func(s capnp.Struct) error { return params(Sender_send_Params{Struct: s}) }
	}
	ans, release := c.Client.SendCall(ctx, s)
	return Sender_send_Results_Future{Future: ans.Future()}, release
}
func (c Chan) Close(ctx context.Context, params func(Closer_close_Params) error) (Closer_close_Results_Future, capnp.ReleaseFunc) {
	s := capnp.Send{
		Method: capnp.Method{
			InterfaceID:   0xfad0e4b80d3779c3,
			MethodID:      0,
			InterfaceName: "channel.capnp:Closer",
			MethodName:    "close",
		},
	}
	if params != nil {
		s.ArgsSize = capnp.ObjectSize{DataSize: 0, PointerCount: 0}
		s.PlaceArgs = func(s capnp.Struct) error { return params(Closer_close_Params{Struct: s}) }
	}
	ans, release := c.Client.SendCall(ctx, s)
	return Closer_close_Results_Future{Future: ans.Future()}, release
}
func (c Chan) Recv(ctx context.Context, params func(Recver_recv_Params) error) (Recver_recv_Results_Future, capnp.ReleaseFunc) {
	s := capnp.Send{
		Method: capnp.Method{
			InterfaceID:   0xdf05a90d671c0c07,
			MethodID:      0,
			InterfaceName: "channel.capnp:Recver",
			MethodName:    "recv",
		},
	}
	if params != nil {
		s.ArgsSize = capnp.ObjectSize{DataSize: 0, PointerCount: 0}
		s.PlaceArgs = func(s capnp.Struct) error { return params(Recver_recv_Params{Struct: s}) }
	}
	ans, release := c.Client.SendCall(ctx, s)
	return Recver_recv_Results_Future{Future: ans.Future()}, release
}

func (c Chan) AddRef() Chan {
	return Chan{
		Client: c.Client.AddRef(),
	}
}

func (c Chan) Release() {
	c.Client.Release()
}

// A Chan_Server is a Chan with a local implementation.
type Chan_Server interface {
	Send(context.Context, Sender_send) error

	Close(context.Context, Closer_close) error

	Recv(context.Context, Recver_recv) error
}

// Chan_NewServer creates a new Server from an implementation of Chan_Server.
func Chan_NewServer(s Chan_Server, policy *server.Policy) *server.Server {
	c, _ := s.(server.Shutdowner)
	return server.New(Chan_Methods(nil, s), s, c, policy)
}

// Chan_ServerToClient creates a new Client from an implementation of Chan_Server.
// The caller is responsible for calling Release on the returned Client.
func Chan_ServerToClient(s Chan_Server, policy *server.Policy) Chan {
	return Chan{Client: capnp.NewClient(Chan_NewServer(s, policy))}
}

// Chan_Methods appends Methods to a slice that invoke the methods on s.
// This can be used to create a more complicated Server.
func Chan_Methods(methods []server.Method, s Chan_Server) []server.Method {
	if cap(methods) == 0 {
		methods = make([]server.Method, 0, 3)
	}

	methods = append(methods, server.Method{
		Method: capnp.Method{
			InterfaceID:   0xe8bbed1438ea16ee,
			MethodID:      0,
			InterfaceName: "channel.capnp:Sender",
			MethodName:    "send",
		},
		Impl: func(ctx context.Context, call *server.Call) error {
			return s.Send(ctx, Sender_send{call})
		},
	})

	methods = append(methods, server.Method{
		Method: capnp.Method{
			InterfaceID:   0xfad0e4b80d3779c3,
			MethodID:      0,
			InterfaceName: "channel.capnp:Closer",
			MethodName:    "close",
		},
		Impl: func(ctx context.Context, call *server.Call) error {
			return s.Close(ctx, Closer_close{call})
		},
	})

	methods = append(methods, server.Method{
		Method: capnp.Method{
			InterfaceID:   0xdf05a90d671c0c07,
			MethodID:      0,
			InterfaceName: "channel.capnp:Recver",
			MethodName:    "recv",
		},
		Impl: func(ctx context.Context, call *server.Call) error {
			return s.Recv(ctx, Recver_recv{call})
		},
	})

	return methods
}

type PeekableChan struct{ Client *capnp.Client }

// PeekableChan_TypeID is the unique identifier for the type PeekableChan.
const PeekableChan_TypeID = 0xb527cbca9bbd8178

func (c PeekableChan) Send(ctx context.Context, params func(Sender_send_Params) error) (Sender_send_Results_Future, capnp.ReleaseFunc) {
	s := capnp.Send{
		Method: capnp.Method{
			InterfaceID:   0xe8bbed1438ea16ee,
			MethodID:      0,
			InterfaceName: "channel.capnp:Sender",
			MethodName:    "send",
		},
	}
	if params != nil {
		s.ArgsSize = capnp.ObjectSize{DataSize: 0, PointerCount: 1}
		s.PlaceArgs = func(s capnp.Struct) error { return params(Sender_send_Params{Struct: s}) }
	}
	ans, release := c.Client.SendCall(ctx, s)
	return Sender_send_Results_Future{Future: ans.Future()}, release
}
func (c PeekableChan) Close(ctx context.Context, params func(Closer_close_Params) error) (Closer_close_Results_Future, capnp.ReleaseFunc) {
	s := capnp.Send{
		Method: capnp.Method{
			InterfaceID:   0xfad0e4b80d3779c3,
			MethodID:      0,
			InterfaceName: "channel.capnp:Closer",
			MethodName:    "close",
		},
	}
	if params != nil {
		s.ArgsSize = capnp.ObjectSize{DataSize: 0, PointerCount: 0}
		s.PlaceArgs = func(s capnp.Struct) error { return params(Closer_close_Params{Struct: s}) }
	}
	ans, release := c.Client.SendCall(ctx, s)
	return Closer_close_Results_Future{Future: ans.Future()}, release
}
func (c PeekableChan) Peek(ctx context.Context, params func(Peeker_peek_Params) error) (Peeker_peek_Results_Future, capnp.ReleaseFunc) {
	s := capnp.Send{
		Method: capnp.Method{
			InterfaceID:   0xe95c7f9f41bf520a,
			MethodID:      0,
			InterfaceName: "channel.capnp:Peeker",
			MethodName:    "peek",
		},
	}
	if params != nil {
		s.ArgsSize = capnp.ObjectSize{DataSize: 0, PointerCount: 0}
		s.PlaceArgs = func(s capnp.Struct) error { return params(Peeker_peek_Params{Struct: s}) }
	}
	ans, release := c.Client.SendCall(ctx, s)
	return Peeker_peek_Results_Future{Future: ans.Future()}, release
}
func (c PeekableChan) Recv(ctx context.Context, params func(Recver_recv_Params) error) (Recver_recv_Results_Future, capnp.ReleaseFunc) {
	s := capnp.Send{
		Method: capnp.Method{
			InterfaceID:   0xdf05a90d671c0c07,
			MethodID:      0,
			InterfaceName: "channel.capnp:Recver",
			MethodName:    "recv",
		},
	}
	if params != nil {
		s.ArgsSize = capnp.ObjectSize{DataSize: 0, PointerCount: 0}
		s.PlaceArgs = func(s capnp.Struct) error { return params(Recver_recv_Params{Struct: s}) }
	}
	ans, release := c.Client.SendCall(ctx, s)
	return Recver_recv_Results_Future{Future: ans.Future()}, release
}

func (c PeekableChan) AddRef() PeekableChan {
	return PeekableChan{
		Client: c.Client.AddRef(),
	}
}

func (c PeekableChan) Release() {
	c.Client.Release()
}

// A PeekableChan_Server is a PeekableChan with a local implementation.
type PeekableChan_Server interface {
	Send(context.Context, Sender_send) error

	Close(context.Context, Closer_close) error

	Peek(context.Context, Peeker_peek) error

	Recv(context.Context, Recver_recv) error
}

// PeekableChan_NewServer creates a new Server from an implementation of PeekableChan_Server.
func PeekableChan_NewServer(s PeekableChan_Server, policy *server.Policy) *server.Server {
	c, _ := s.(server.Shutdowner)
	return server.New(PeekableChan_Methods(nil, s), s, c, policy)
}

// PeekableChan_ServerToClient creates a new Client from an implementation of PeekableChan_Server.
// The caller is responsible for calling Release on the returned Client.
func PeekableChan_ServerToClient(s PeekableChan_Server, policy *server.Policy) PeekableChan {
	return PeekableChan{Client: capnp.NewClient(PeekableChan_NewServer(s, policy))}
}

// PeekableChan_Methods appends Methods to a slice that invoke the methods on s.
// This can be used to create a more complicated Server.
func PeekableChan_Methods(methods []server.Method, s PeekableChan_Server) []server.Method {
	if cap(methods) == 0 {
		methods = make([]server.Method, 0, 4)
	}

	methods = append(methods, server.Method{
		Method: capnp.Method{
			InterfaceID:   0xe8bbed1438ea16ee,
			MethodID:      0,
			InterfaceName: "channel.capnp:Sender",
			MethodName:    "send",
		},
		Impl: func(ctx context.Context, call *server.Call) error {
			return s.Send(ctx, Sender_send{call})
		},
	})

	methods = append(methods, server.Method{
		Method: capnp.Method{
			InterfaceID:   0xfad0e4b80d3779c3,
			MethodID:      0,
			InterfaceName: "channel.capnp:Closer",
			MethodName:    "close",
		},
		Impl: func(ctx context.Context, call *server.Call) error {
			return s.Close(ctx, Closer_close{call})
		},
	})

	methods = append(methods, server.Method{
		Method: capnp.Method{
			InterfaceID:   0xe95c7f9f41bf520a,
			MethodID:      0,
			InterfaceName: "channel.capnp:Peeker",
			MethodName:    "peek",
		},
		Impl: func(ctx context.Context, call *server.Call) error {
			return s.Peek(ctx, Peeker_peek{call})
		},
	})

	methods = append(methods, server.Method{
		Method: capnp.Method{
			InterfaceID:   0xdf05a90d671c0c07,
			MethodID:      0,
			InterfaceName: "channel.capnp:Recver",
			MethodName:    "recv",
		},
		Impl: func(ctx context.Context, call *server.Call) error {
			return s.Recv(ctx, Recver_recv{call})
		},
	})

	return methods
}

const schema_872a451f9aa74ebf = "x\xda\x8cU]h#U\x14>'\xf7\xde\x9d\x1a6" +
	"N'\xb7\xae \x8b\x11)\x1bX4t\xbb\xe0\xca\xb2" +
	"\x8b\x1bJ\x09\x0a]f\xaa\x82\xc2\xbe\x8c\xe9\xad\x85\xa6" +
	"\xb1$m\xa9\x85\"}(Z\x8aH\xc1<\x18\x85\xea" +
	"S1/UhA\xa9\xda\x07\x11lZ\xc1\xbeYQ" +
	"D\x10\xfa\xa3-\x14,\xdaB\x19\xb93\xccO\x92I" +
	"\xecS\xc2\xdc\xef\x9c\xef;\xe7|\xf7\xdc\xae\xa7\"\xf7" +
	"\xe8\x8d\xd8\xee%\x88\x18:\xbbdU'\x0f\xef~\xf4" +
	"\xd5\xe0\x0ch\x8f \x00C\xa5\x1do\xbeJ\xa2\x08\xc8" +
	"M\xf2\x1c\xa0e\xfc3\xb8\xb3\xbb\xf8}\x09\xb4\x87\x89" +
	"\xb5~\x7f\xa9\x9c\xe8\xbd\xfe6\x00\xb4#\x9f!e>" +
	"G\x14\x00>K\x14>K\x92\xfc\x84\xa8\xd6\x9d\x87V" +
	"\xb7\xfe]\x7f\xa1\x1c\x12\xb0O\xaa\xfc\xc4\x0e8&\x0a" +
	"?&InR\xd5z\xe7\xc9\xf6\xa9\xb3\xc7\xaf-;" +
	"\x12\xa8T\xf02\x8d\"P\xeb\xfd+\xb7\xa3}\xef\xed" +
	"}\x16\x14w\x97\xc6\xa5\xb8^*\xc5}\xfcM\xf7\xe1" +
	"\xfcQj%\x08\x10\x0e`\xc4\x06L\xce|\xfdau" +
	"3\xb9\x1a\"\xe6]\xfa3\xff\x80J1%\xaa\xf0\x12" +
	"Mr\xc6T\xeb\xcf\x95'\xb6\xfe\xc2\x1bk\x011\xa7" +
	"2!\xb5\x0e\xfe\x9e\x9a_~p\xb4\xe9\x9e\x00\xdc\xfc" +
	"\x9d>f\x9f\\\xeb\x8c\xfd2}\xeb\xd7@\xcc\x86S" +
	"\x80r\xf9\xea\xeb\xb1O\xd9o!\xf4\x9f\xd3\x0a\xff\xd2" +
	"\xa6_\xa5\x19\xce\x98b\xd3\x1f]9x\xb6\xe3pm" +
	"/$\xe0\x94V82\x19pN3\xbc\x8f)\xbc\x8f" +
	"\xa9V\xb4\x7f=\xbd\xf8\xd6\x83\xfd\x90\x804\xab\xf0\xe7" +
	"\xed\x80^\x96\xe1%\xa6\xf0\x12S\xad\xfb\xfb\x1d\xd3\xe5" +
	"\xed\xa5\xb0\x809V\x950\x00\xbe\xc0\x14\xbe\xc0\x92|" +
	"\x9b\xa9\xd6\xb7o\xde\x8a}\xf1\xc7\x8fgu\x01\xc8\xbf" +
	"c\x15\xfe\x83\x0d\xdf`\x19~,\xffYw^yf" +
	"\xeb\x93\x9f\x94\xf3@\x93vX\x1c\xa1\xcb\xca\x0e\x99\xf9" +
	"\xbc\xc8\xa5H\xd6\x1c\xcd\x8f\xde~Q\xe4\x07D!U" +
	"\x14\xf9\x81N\xdd,\x98#E\x00\x83\x12\x0a@\x11@" +
	"\x8bu\x03\x18m\x04\x8d\x8e\x08&&\xcc\xdc\xb8\xc08" +
	"\xa2\xdf\x1e\x00\x8c\x03zI\xd1I\xda3D\xcc\xbc\x8e" +
	"\xa8\x13f\xb4!\xfa\xb5\xa6\xdb\xd0\x9fE\xba\x0b5L" +
	"\x184\x12\x00\x00h\xf8\xa8A\x11e0\xda\\\x9e\xf1" +
	"\xe5\x99\x03\xf7R\xb4\x86\xa7)j\x18\xc7\x97<y\x11" +
	"G\x9e.\xc4p\xbf\xc8N\x88\x02@@\xa57\xc2f" +
	"*=@\x08\xadw\xdb.\xa62\x00oPI|\x95" +
	"\xa2\x90\x1a\x15b\xd8\x9bL=\xc6\xa9\"U\x10\xd9\x89" +
	"\xce~Q\x1c\xcf\x8da\xf1\xff\xa7\x17\x10V3\xbd\x10" +
	"\xe2\x8b'\x0d4\xa7&i\xa0\xe7\xe6k9\xd1\xd2\x1a" +
	"^W.h\x0do\xab\xf8M\xaf\x99Csx\xb3\xa6" +
	"\x07\xaf\x83[{=\xa6'\xf7FQ\x14RY\xf9\xe3" +
	"\x80\xc8X\xb1\xd5d\x1a\xa6\x87.F\x95 \x1d\xd1\xa0" +
	"\x84\x01x\x0b\x0c\xdd\x85\xabi\xd7\x01\xd2\x971}\x15" +
	"\xb5\xa7\x15Ufkp\x17b\x88\xe5\xe4\xc7{\xa8#" +
	"6\x14\x8an\xa1\xaa\xac\xd4\xe7v\x1f t7o\x1d" +
	"\xb7l\x89K\xe3]\xff w\xcd\xc7\x96\xdc\xbaP\xa5" +
	"\xc3|n\xf7\xe5A\xf7\x1d\xa9\xe3\x96Vl\xb8\x84A" +
	"\xee\x9a\x8f\xe1\xdc\x11\x7f\xc0\xce\x00k\xee\xbe'^\xda" +
	"\xd0\xdb\xb4!\xc5\x85\xd8*\xe0\xd0f\x15\xf7\xe4TI" +
	"\xe9W\xec\xeegt_3M\xeb\x86\x88\xc6\x94\x84m" +
	"+\xbb\x84\x96\xbe\xb3=\x85\xc5\xff\x02\x00\x00\xff\xff\xb9" +
	"YVl"

func init() {
	schemas.Register(schema_872a451f9aa74ebf,
		0x8166bc9c3ded78ca,
		0x95c89fe7d966f751,
		0x9a4abff8ccb5093c,
		0xaf261efa7a102288,
		0xb0e88f4d0a3a1694,
		0xb42eee8bed32bea0,
		0xb527cbca9bbd8178,
		0xbb3101eccc20b4eb,
		0xcbee5caf8b7af4ea,
		0xdd377ddc0d2426ea,
		0xdf05a90d671c0c07,
		0xe8bbed1438ea16ee,
		0xe95c7f9f41bf520a,
		0xe9a7d19a7d14e94e,
		0xfad0e4b80d3779c3,
		0xfd07d8a1cc36583c)
}
